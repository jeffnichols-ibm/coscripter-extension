/*
This Program contains software licensed pursuant to the following: 
MOZILLA PUBLIC LICENSE
Version 1.1
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.
The Original Code is IBM.
The Initial Developer of the Original Code is IBM Corporation.
Portions created by IBM Corporation are Copyright (C) 2007
IBM Corporation. All Rights Reserved.
Contributor(s): Greg Little, Allen Cypher (acypher@us.ibm.com), Tessa Lau, Clemens Drews, James Lin, Jeffrey Nichols, Eser Kandogan, Jeffrey Wong, Gaston Cangiano, Jeffrey Bigham.

This Program also contains code packages known as chickenfoot 0.9, developer.mozilla.org sample code, and mozInnerHTML that are licensed pursuant to the licenses listed below. 
chickenfoot 0.9 
The program known as chickenfoot 0.9 is licensed under the terms of the MIT license. Those terms are reproduced below for your reference.


The MIT License
Copyright (c) 2004-2007 Massachusetts Institute of Technology
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions: 
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software. 
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

developer.mozilla.org sample code 
The program known as developer.mozilla.org sample code is licensed under the terms below. Those terms are reproduced below for your reference.

The MIT License
Copyright (c) 2007 Mozilla
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions: 
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software. 
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. 

mozInnerHTML
The program known as mozInnerHTML is licensed under the terms of the Apache 2.0 license, 
available at http://www.apache.org/licenses/LICENSE-2.0. 
Those terms are reproduced below for your reference.

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS


*/

///////////////////////////////////////////////////
//////////////  coscripter-utils.js  //////////////
////////////////////////////////////////////////
// the coscripter-utils.js component includes:
// the Ident constructor, which lists all of the words that might be associated with a given html tag
// 'Execution' routines to perform recorded commands by typing and clicking in the browser window
// 	e.g. select, toggle, click, appendText, enter
// Lots of routines with a 'thenDoThis' parameter
// getLabel, which looks at nearby text objects that a user might use to refer to an element on a web page
// There are sections below for Execution and Main CoScripter Windows
//
//  SECTIONS:
//
// Debugging functions
// Utility functions for arrays, strings, sets, and bags
// Window accessors
//	Main CoScripter Windows
//	Support for multiple windows
// Functions to access and manipulate the CoScripter sidebar
// The Ident object
// Functions to load/save data to files in the filesystem
// String utility functions
// Utility functions for documents and nodes
//		NodeUtility
// XPath functions
//
//	Dojo
//		Dijits
//		Dojo Utilities
//
//	Xul
//		getXulNode
//		findXulTargets
//		Xul utilities
//
// XMLHttpRequest-oriented functions
// Highlight nodes in an HTML document
//		highlightNode
// Timing: wait for a page to load, then do something else
//
///////////// Execution ////////////
//	Select
//	Click
//		constructMouseEvent
//	Enter
// Functions for generating recorded slop
// findUniqueDescriptor
// Preferences utility functions
// Koalescence API functions and CoScripter version
Components.utils.import("resource://coscripter-platform/component-registry.js");

var EXPORTED_SYMBOLS = ["utils"];
var utils = this ; 

const CC = Components.classes, CI = Components.interfaces, CIS = CI.nsISupports
var consoleService = CC['@mozilla.org/consoleservice;1']
			.getService(CI.nsIConsoleService);
/*
// To generate native clicks:
// https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsIDOMWindowUtils
// sendNativeMouseEvent()
var domWindowUtils = window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
                     .getInterface(Components.interfaces.nsIDOMWindowUtils);
*/			

var MAX_LABEL_LENGTH = 75	// (AC) Used by TargetSpec.toSlop() to truncate very long labels.


// ----------------------------------------------------------------------
// Debugging functions

var DEBUG = false;

function d(msg) {
	if (DEBUG) {
		dump(msg);
		debug(msg);
	}
}

function debug(msg) {
	consoleService.logStringMessage(msg);
}

// End debugging functions
// ----------------------------------------------------------------------



// this is a regular expression for seeing if a string is a url,
// e.g. "http://www.google.com/search".match(/^file:\/\/|((http|https|ftp):\/\/)?[0-9a-zA-Z]+(\.[0-9a-zA-Z]+)+/)
var urlRegex =/^file:\/\/|((http|https|ftp):\/\/)?[0-9a-zA-Z]+(\.[0-9a-zA-Z]+)+/

// ----------------------------------------------------------------------
// Utility functions for arrays, strings, sets, and bags
// ----------------------------------------------------------------------

// hopefully handles all datatypes
function notEmpty(item) {
	if (typeof item == "string") return (item != "")
	if (typeof item != "object") return (item != null)
    if (item instanceof Array) return (item.length > 0)
	return !emptyObjectP(item)
}

// I'm slowly expanding strict-parser to accept variableValues in lots of places that previously expected a string or a number literal. (AC)
//This function will work with either a literal or a variableValue object
function getStrValue(item) {
	if (typeof item == "string") return item
	if (typeof item == "number") return String(item)
	if (typeof item == "object") return getStrValue(item.getValue())
	throw (item.toString + " broke getStrValue in utils")
}

// I'm slowly expanding strict-parser to accept variableValues in lots of places that previously expected a string or a number literal. (AC)
//This function will work with either a literal or a variableValue object
function getNumValue(item) {
	if (typeof item == "string") return parseInt(item)
	if (typeof item == "number") return item
	if (typeof item == "object") return getNumValue(item.getValue())
	throw (item.toString + " broke getStrValue in utils")
}


// Objects
//returns true if obj is {}
//returns false if obj is not an object
//returns false if obj has been assigned some property
function emptyObjectP(obj) {
	if (typeof obj != "object") return false
	var prop = null
	var propCount = 0
	for (prop in obj) {propCount += 1}
	return (propCount == 0)
}


// Arrays

// returns true iff "beginsWith" is a prefix of *array*,
// e.g. arrayBeginsWith([1, 5, 7, 11, 21], [1, 5, 7]) returns true
// e.g. arrayBeginsWith([1, 5, 7, 11, 21], [1, 5, 6]) returns false
function arrayBeginsWith(array, beginsWith) {
    for (var i = 0; i < beginsWith.length; i++) {
        if (i >= array.length || array[i] != beginsWith[i]) {
            return false
        }
    }
    return true
}

// if the *array* is bigger than *size*, it won't be after calling this function
function trimArrayToSize(array, size) {
    if (array.length > size) {
        array.splice(size, array.length - size)
    }
}

// returns true if item is an element in array
function inArrayP(item, array) {
	for (var i=0; i<array.length; i++) {
		if (item == array[i]) return true
	}
	return false
}

function inArrayAtIndex(item, array) {
	for (var i=0; i<array.length; i++) {
		if (item == array[i]) return i
	}
	return -1
}

function inListP(item, list) {
	for (var i=0; i<list.length; i++) {
		if (item == list[i]) return i+1
	}
	return false
}

// returns the arrays length, if it exists, or 0 if it doesn't (instead of throwing an exception)
function safeLength(array) {
    if (array) {
        return array.length
    } else {
        return 0
    }
}

// Use .iterateNext() to go through an Iterator and collect all of its values in a list
function iteratorToList(iterator) {
	var resultList = []
	var item
	while (item = iterator.iterateNext()) {
		resultList.push(item)
	}
	return resultList
}

// Use .iterateNext() to go through an Iterator and collect all of its values in a list
function enumeratorToList(enumerator) {
	var resultList = []
	var item
	while (item = enumerator.getNext()) {
		resultList.push(item)
	}
	return resultList
}

// returns a number in the range [0 ... size-1],
// usful for indexing into 0-based arrays
// used by the stable sort, below
function randomIndex(size) {
    return Math.floor(Math.random() * size);
}

// javascript's Array.sort function isn't stable (by the fancy computer science definition),
// but this function is... which is useful sometimes
function stableSort(array, sortFunc) {
    for (var i = 0; i < array.length; i++) {
        stableSort_helper_binaryInsertion(array, 0, i, array.splice(i, 1)[0], sortFunc)
    }
}
function stableSort_helper_binaryInsertion(array, start, end, element, sortFunc) {
    if (start == end) {
        array.splice(start, 0, element)
        return
    }
    var i = start + randomIndex(end - start)
    if (sortFunc(element, array[i]) >= 0) {
        stableSort_helper_binaryInsertion(array, i + 1, end, element, sortFunc)
    } else {
        stableSort_helper_binaryInsertion(array, start, i, element, sortFunc)
    }
}


// Strings

function getOrdinal(number){
	var ordinals = ["zeroth", "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth", "eleventh", "twelfth", "thirteenth", "fourteenth", "fifteenth", "sixteenth", "seventeenth", "eighteenth", "nineteenth"]
	if (number < 20) return ordinals[number]
	var numberString = number.toString()
	switch (numberString.charAt(numberString.length-1)) {
		case "1": 	return numberString + "st"
		case "2": 	return numberString + "nd"
		case "3": 	return numberString + "rd"
		default: 	return numberString + "th"
	}
}

// Given an ordinal string, such as "first", return the cardinal integer
// corresponding to that string (e.g., 1)
function getCardinal(ordinal) {
	if (!ordinal) return null;
	var ordinals = ["zeroth", "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth", "eleventh", "twelfth", "thirteenth", "fourteenth", "fifteenth", "sixteenth", "seventeenth", "eighteenth", "nineteenth"]
	var i = ordinals.indexOf(ordinal);
	if (i != -1) return i;
	// otherwise look for a number
	var r = /^([0-9]+)/;
	var match = r.exec(ordinal);
	if (match) {
		return parseInt(match[1])
	}
	return null;
}

// determine if the string contains an ordinal.
//if it does return an array of three substrings: (preOrdinal, ordinal, postOrdinal)
//need to fix this to return multi-word ordinals like "seven hundred twenty-fifth"
//need to handle "742nd"
function findOrdinalIn(string) {
	var ordinals = ["zeroth", "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth", "eleventh", "twelfth", "thirteenth", "fourteenth", "fifteenth", "sixteenth", "seventeenth", "eighteenth", "nineteenth", "twentieth", "thirtieth", "fourtieth", "fiftieth", "sixtieth", "seventieth", "eightieth", "ninetieth", "hundredth", "thousandth", "millionth", "billionth", "trillionth"]
	var stringLC = string.toLowerCase()
	var index, ordinal
	for (var i = 0; i<ordinals.length; i++) {
		ordinal = ordinals[i]
		index = stringLC.indexOf(ordinal)
		if (index + 1) {
			return [string.substring(0, index), 
							string.substring(index, index+ordinal.length), 
							string.substring(index+ordinal.length)]
		}
	}
	return false
}

function ordinalP(string) {
	var ordinals = ["zeroth", "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth", "eleventh", "twelfth", "thirteenth", "fourteenth", "fifteenth", "sixteenth", "seventeenth", "eighteenth", "nineteenth"]
	string = string.toLowerCase()
	var ending = string.slice(-1 * Math.min("seventeenth".length, string.length))
	return ordinals.indexOf(ending)+1 ? true : false
}

// used by getLabel
function truncateLabel(string) {
	if (!string || string == "") return string
	if (string.length < MAX_LABEL_LENGTH) return string
	return string.substring(0, MAX_LABEL_LENGTH-3) + "..."
}

function generateUUID(){
	var uuidGenerator = Components.classes["@mozilla.org/uuid-generator;1"].getService(Components.interfaces.nsIUUIDGenerator);
	var guid = uuidGenerator.generateUUID();
	var guidString = guid.toString();
	guidString = guidString.substring(1,guidString.length-1)
	//debug("guidString is " + guidString)
	return guidString	
}

// Sets

// for me, sets are usually objects where the keys are the elements, and the values are all 1
// e.g. makeSet(["a", "b", "c", "b", "a"]) == {"a" : 1, "b" : 1, "c" : 1}
function makeSet(array) {
    var set = {}
    for (var i = 0; i < array.length; i++) {
        set[array[i]] = 1
    }
    return set
}

// *set* is really just an array, and we're seeing if *element* is in it,
// e.g. if (inSet([1, 2, 3], 1)) { alert("good!") }
function inSet(set, element) {
    for (var i in set) {
        var a = set[i]
        if (a == element) {
            return true
        }
    }
    return false
}


// Bags

// var bag = {"a" : 1, "b" : 7, "c" : 4}
// bagGet(bag, "b") == 7
// bagGet(bag, "d") == 0 // NOTE: it returns 0 and not null, meaning we have 0 d's in our bag, not null of them
function bagGet(map, entry) {
    var value = map[entry]
	//need  to handle javascript error when entry is "watch" -- a function is returned
    return ((typeof value) != "number") ? 0 : value
}

// Objects

// say you have { "blah" : 5, "bloop" : 7, "foobar" : 1 },
// this will return: "blah : bloop : foobar",
// which is useful for seeing what functions and attributes are available on xul and html objects
function listProperties(obj) {
    var s = ""
    for (var key in obj) {
        s += " : " + key
    }
    return s
}


// ----------------------------------------------------------------------
// End utility functions for arrays, bags, and sets
// ----------------------------------------------------------------------


// ----------------------------------------------------------------------
// Scratch space utilities	

function convertColumnNumberToLetter(columnNum) {
	// TODO should return, for example, AA for 27
	return String.fromCharCode(columnNum + 'A'.charCodeAt(0));
}
	
function convertLetterToColumnNumber(columnLetter) {
	// TODO should return, for example, 27 for AA
	return columnLetter.charCodeAt(0) - 'A'.charCodeAt(0) + 1;
}

// ----------------------------------------------------------------------
// End scratch space utilities
// ----------------------------------------------------------------------


// ----------------------------------------------------------------------
// Clipboard utilities

function sendToClipboard(text) {
	var gClipboardHelper = Components.classes["@mozilla.org/widget/clipboardhelper;1"].getService(Components.interfaces.nsIClipboardHelper); 
	gClipboardHelper.copyString(text)
}
	
function getClipboardContentsAsText() {
	var clip = Components.classes["@mozilla.org/widget/clipboard;1"].getService(Components.interfaces.nsIClipboard); 
	if (!clip) return null; 
	
	var trans = Components.classes["@mozilla.org/widget/transferable;1"].createInstance(Components.interfaces.nsITransferable); 
	if (!trans) return null; 
	trans.addDataFlavor("text/unicode");
	
	clip.getData(trans,clip.kGlobalClipboard); 
	var str = new Object(); 
	var strLength = new Object(); 
	trans.getTransferData("text/unicode",str,strLength);
	
	if (str) str = str.value.QueryInterface(Components.interfaces.nsISupportsString); 
	
	var pastetext = "";
	if (str) pastetext = str.data.substring(0,strLength.value / 2);
	
	return pastetext;
}

// This copies the selected node to the system clipboard as both HTML and
// text flavors
// See https://developer.mozilla.org/en/using_the_clipboard
function copyHTMLToSystemClipboard(target) {
	// Copy the clip region to the system clipboard
	// var clipboardHelper = Components.classes["@mozilla.org/widget/clipboardhelper;1"].
//										getService(Components.interfaces.nsIClipboardHelper);  
	// clipboardHelper.copyString(target.innerHTML);

	// Make a copy of the HTML
	var htmlstr = Components.classes["@mozilla.org/supports-string;1"].
		createInstance(Components.interfaces.nsISupportsString);
	if (!htmlstr) {
		return;
	}
	htmlstr.data = target.innerHTML;
	var html_length = target.innerHTML.length;

	// Make a copy of the text
	var str = Components.classes["@mozilla.org/supports-string;1"].
		createInstance(Components.interfaces.nsISupportsString);
	if (!str) {
		return;
	}
	var labeler = getLabeler();
	str.data = labeler.getText(target, true);
	var str_length = str.data.length;

	// Add Unicode & HTML flavors to the transferable widget
	var trans = Components.classes["@mozilla.org/widget/transferable;1"].
		createInstance(Components.interfaces.nsITransferable);
	if (!trans) {
		return;
	}

	trans.addDataFlavor("text/html");
	// *2 because it's unicode, according to the sample code from MDC
	trans.setTransferData("text/html", htmlstr, html_length*2);

	trans.addDataFlavor("text/unicode");
	// *2 because it's unicode, according to the sample code from MDC
	trans.setTransferData("text/unicode", str, str_length*2);

	var clipboard = Components.classes["@mozilla.org/widget/clipboard;1"].
			getService(Components.interfaces.nsIClipboard);
	if (!clipboard) {
		return;
	}
	clipboard.setData(trans, null, Components.interfaces.nsIClipboard.kGlobalClipboard);
}

// ----------------------------------------------------------------------
// End clipboard utilities
// ----------------------------------------------------------------------


// ----------------------------------------------------------------------
// Window accessors

/* given a window, even a window inside a webpage,
// this will find the parent main xul chrome window...
// to cross the xul/html boundary,
// it looks in each chrome window to see which one has our candidate window */
function getChromeWindowForWindow(win) {
    while (win != win.parent) {
        win = win.parent
    }
    if (win.wrappedJSObject) {
        win = win.wrappedJSObject
    }
    
    var chromeWindows = listWindows()
    for (var i = 0; i < chromeWindows.length; i++) {
        var chromeWindow = chromeWindows[i]
        if (chromeWindow == win) {
            return chromeWindow
        }
        var frames = chromeWindow.frames
        for (var ii = 0; ii < frames.length; ii++) {
            var frame = frames[ii]
            // this is new and unfortunate in FF40. Objects coming from the window mediator 
            // are wrapped with a wrappedJSObject. The comparison below now fails (win == frame)
            // unless we specifically unwrap the frame as well. CD 3/10/2011
            if (frame.wrappedJSObject) {
                frame = frame.wrappedJSObject ;
            }
            if (frame == win) {
                return chromeWindow
            }
        }
    }
}

/* given a node, even inside a webpage,
// this will find the parent main xul chrome window,
// see getChromeWindowForWindow above */
function getChromeWindowForNode(node) {
    return getChromeWindowForWindow(node.ownerDocument.defaultView)
}

/* gets the window closest to the user (presumably the most recently accessed window),
// note this could be a dialog, unless you specify a different type with *ofType*,
// but I don't have a list of types (I don't think "dialog" is a good type name,
// "navigator:browser" is a good name... you can find good names using the DOM inspector) */
function getTopWindow(ofType) {
    // ofType is optional, see http://www.xulplanet.com/references/xpcomref/ifaces/nsIWindowMediator.html#method_getMostRecentWindow
    var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"].getService(Components.interfaces.nsIWindowMediator)
    return wm.getMostRecentWindow(ofType)
}

// here, "main window" refers to a non-dialog window (one of the firefox windows with the menu-bar and html browser)
function mostRecentMainWindow() {
    return getTopWindow("navigator:browser")
}

// returns an array of windows ordered from oldest to newest (in terms of when they were *created*, not modified)
function listWindows() {
    var windows = []
    var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"].getService(Components.interfaces.nsIWindowMediator)
    var e = wm.getEnumerator(null)
    while (e.hasMoreElements()) {
        var w = e.getNext()
        windows.push(w)
    }
    return windows
}

/* say you have a pointer to a xul window which happens to be a sidebar,
// and you want a pointer to the main firefox window that it is sitting in,
// then call getWindowRoot(mySidebarPointer)
// NOTE: in the case of a sidebar, this would be equivalent to mySidebarPointer.parent, but oh well */
function getWindowRoot(win) {
    while (win.parent && win != win.parent) {
        win = win.parent
    }
    return win
}

/* gets the selected browser for this firefox content window
//Doesn't Work for a sidebar window
// NOTE: you can pass any xul window handle that is in the firefox window,
// because it will follow the window to the root to get the main one */
function getBrowser(chromeWindow) {
    chromeWindow = getWindowRoot(chromeWindow)
    var tabBrowser = chromeWindow.document.getElementById("content")
    return tabBrowser ? tabBrowser.selectedBrowser : null
}

/* gets the window for the main browser for this firefox window,
// i.e., the thing that has functions like "alert" */
function getBrowserWindow(chromeWindow) {
    return getBrowser(chromeWindow).contentWindow
}

/* gets the document for the main browser for this firefox window,
// i.e., the root of the DOM for the HTML displayed in the browser */
function getBrowserDocument(chromeWindow) {
	if(!chromeWindow) return null
	try {
		var browser = getBrowser(chromeWindow)
		if(!browser) return null
    	return browser.contentDocument
    } catch (e) {
		dump('utils: getBrowserDocument: ' + e + '\n');
        return false
    }
}

///////////////////////////
//	Main CoScripter Windows
///////////////////////////
/*	CoScripter Window organization
	Firefox's mainChromeWindow has an element with id="browser" which contains everything below Firefox's toolbar (so it contains both the sidebar and the tabBrowser).  
	This browser contains an element with id="sidebar-box" that contains both 1) a bar that says "CoScripter" and has a closeBox on the right, and
2) the sidebar browser with id="sidebar", which has a contentWindow and contentDocument. 
	The contentWindow has id="coscripterWindow".  It is a ChromeWindow and its document is the #document XULDocument whose child is loaded from coscripter-sidebar.xul. 
"coscripter-sidebar.js" is loaded into coscripterWindow, so this is the true CoScripter sidebar window.
	coscripter-sidebar.xul contains a XUL "page" element which has the coscripter toolbar buttons, the dbWindows, and 
the "scriptArea", which displays either the "welcomePage" or, most importantly, the "procedureInteractorBrowser", which contains the Editor (aka Procedure Interactor).
*/

/*sidebarBrowser always exists in top-level Browsers, even if the sidebar has never been opened.
//windows like "Error Console" don't have a sidebarBrowser */
function getSidebarBrowser(aWindow) {	
	var mainChromeWindow = getMainChromeWindow(aWindow)
	if (!mainChromeWindow) return null
	return mainChromeWindow.document.getElementById("sidebar")
}

/* tabbrowser is a special XULElement that contains information about all of the browsers that are in tabs in a mainChromeWindow
//it is not a browser itself, although it is given properties like contentWindow and contentDocument that point to the corresponding items
//in the current browser
//this function was previously called getChromeTabBrowser */
function getMainTabbrowser(aWindow) {
	var mainChromeWindow = getMainChromeWindow(aWindow)
	if (!mainChromeWindow) return null
	return mainChromeWindow.document.getElementById("content");
}

function getCoScripterWindow(aWindow) {
	var sidebarBrowser = getSidebarBrowser(aWindow)
	if (!sidebarBrowser) return null
	// The sidebarBrowser always exists, even if the sidebar has never been opened.
	//  But if the sidebar is closed, it has no contentWindow property, so just *asking* for the value triggers a typeError
	//debug("in utils getCoScripterWindow")
	var contentWindow = sidebarBrowser.docShell ? sidebarBrowser.contentWindow : null
	//if (!sidebarBrowser.docShell) debug("sidebarBrowser.docShell is null")
	//debug("returning")

	if (contentWindow && (contentWindow.document.title == "coscripter-sidebar" || contentWindow.coscripterFamily == true)){
		return contentWindow
	}
	return null
}

function listCoscripterWindows() {
    var windows = []
    var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"].getService(Components.interfaces.nsIWindowMediator)
    var e = wm.getEnumerator(null)
    while (e.hasMoreElements()) {
        var w = e.getNext()
		var cw = getCoScripterWindow(w)
        if (cw) windows.push(cw)
    }
    return windows
}

function getProcedureBrowser(aWindow) {
	var coscripterWindow = getCoScripterWindow(aWindow)
	return coscripterWindow ? coscripterWindow.document.getElementById("procedureBrowser") : null
}

 
function getSidebarElement(aWindow, id) {
   var coscriptorWindow = getCoScripterWindow(aWindow);
   return coscriptorWindow ? coscriptorWindow.document.getElementById(id) : null;
}
    
function getServerWelcomePage(aWindow) {
   return getSidebarElement(aWindow, "serverWelcomePage");
}
    
function getLocalWelcomePage(aWindow) {
   return getSidebarElement(aWindow, "localWelcomePage");
}
    
function getProcedureInteractorBrowser(aWindow) {
   return getSidebarElement(aWindow, "procedureInteractorBrowser");
}
function getProcedureInteractor(aWindow) {
   return getSidebarElement(aWindow, "procedureInteractor");
}
	
function getProcedureInteractorBody(aWindow) {
   var procedureInteractorBrowser = getProcedureInteractorBrowser(aWindow);
   return procedureInteractorBrowser ? procedureInteractorBrowser.contentDocument.getElementById("procedureInteractorBody") : null;
}
	
function getSavePanel(aWindow) {
   return getSidebarElement(aWindow, "savePanel");
}

function getProcedureTitleTextBox(aWindow) {
   return getSidebarElement(aWindow, "procedureTitle");
}
     
function getProcedurePrivateButton(aWindow) {
   return getSidebarElement(aWindow, "procedurePrivate");
}

function getToWikiButton(aWindow) {
   return getSidebarElement(aWindow, "toWiki");
}

function getStatusLabel(aWindow) {
   return getSidebarElement(aWindow, "statusLabel");
}

// To support multiple windows, whenever getCurrentChromeWindow is called,
// get the ChromeWindow where CoScripter is running 
function getCurrentChromeWindow() {
	var windowWatcher = CC["@mozilla.org/embedcomp/window-watcher;1"].getService(CI.nsIWindowWatcher)
	var activeWindow = windowWatcher.activeWindow
	if (!activeWindow){
		//debug("utils.getCurrentChromeWindow: **nsIWindowWatcher has NO activeWindow**")
		var windowMediator = CC["@mozilla.org/appshell/window-mediator;1"].getService(CI.nsIWindowMediator)
		var topWindow = windowMediator.getMostRecentWindow("navigator:browser")
		//debug("utils.getCurrentChromeWindow: **nsIWindowMediator has mostRecentWindow = " + topWindow.document.title)
		return topWindow
	}
	//debug("utils.getCurrentChromeWindow: **nsIWindowWatcher has activeWindow = " + activeWindow.document.title)
	return activeWindow
}

// Returns the MainChromeWindow where this script is running
function getCoScripterChromeWindow(sidebarWindow) {
	return sidebarWindow.top
}

/*
function getCurrentChromeWindow() {
	var windowWatcher = CC["@mozilla.org/embedcomp/window-watcher;1"].getService(CI.nsIWindowWatcher)
	var activeWindow = windowWatcher.activeWindow
	if (!activeWindow){
		//debug("utils.getCurrentChromeWindow: **nsIWindowWatcher has NO activeWindow**")
		var windowMediator = CC["@mozilla.org/appshell/window-mediator;1"].getService(CI.nsIWindowMediator)
		var topWindow = windowMediator.getMostRecentWindow("navigator:browser")
		//debug("utils.getCurrentChromeWindow: **nsIWindowMediator has mostRecentWindow = " + topWindow.document.title)
		return topWindow
	}
	//debug("utils.getCurrentChromeWindow: **nsIWindowWatcher has activeWindow = " + activeWindow.document.title)
	return activeWindow
}
*/

function getMainChromeWindow(aWindow) {
	var contentBrowser = getContentBrowser(aWindow)
	if (contentBrowser) return contentBrowser.ownerDocument.defaultView
	else return aWindow.top
}

/* a contentBrowser is one of the browsers that is a tab in a mainChromeWindow
// web pages are loaded into its contentWindow */
function getCurrentContentBrowser(aWindow) {
	var mainChromeWindow = getMainChromeWindow(aWindow)
	if (!mainChromeWindow) return null
	var browsersElement = mainChromeWindow.document.getElementById("content")	// this XULElement has nodeName="tabbrowser"
	// browsersElement has browsers and contentDocument and contentWindow properties
	if (browsersElement) {
		var currentBrowser = browsersElement.mCurrentBrowser	// there is also a selectedBrowser property (which may be different??)
		var selectedBrowser = mainChromeWindow.gBrowser.selectedBrowser	// alternate approach
		if (currentBrowser != selectedBrowser) debug("getCurrentContentBrowser: the two ways are NOT the same")
	}
	if (browsersElement) return browsersElement.selectedBrowser
	return null
}


/////////////////////
//	Support for multiple windows
// Commands can now have window descriptors

// getWindowFromCommand(command)
function getWindowFromCommand(command){
	var targetSpec = command.targetSpec
	if (!targetSpec) return null
	return getWindowFromTargetSpec(targetSpec)
}

function getWindowFromTargetSpec(targetSpec){
	if (!targetSpec) return null
	var window = null 
	var windowName = targetSpec.windowName
	var windowId = targetSpec.windowId
	if (windowName) window = getWindowByName(windowName)
	if (!window && windowId) window = getWindowById(windowId)
	return window
}

function getWindowByName(windowName){
    var windowMediator = Components.classes["@mozilla.org/appshell/window-mediator;1"].getService(Components.interfaces.nsIWindowMediator)
    var enumerator = windowMediator.getEnumerator(null)
    while (enumerator.hasMoreElements()) {
        var window = enumerator.getNext()
		if ((window.name == windowName) || (window.document.title == windowName)) return window
    }
    return null
}

function getWindowById(windowId){
    var windowMediator = Components.classes["@mozilla.org/appshell/window-mediator;1"].getService(Components.interfaces.nsIWindowMediator)
    var enumerator = windowMediator.getEnumerator(null)
    while (enumerator.hasMoreElements()) {
        var window = enumerator.getNext()
        if (window.id == windowId) return window
    }
    return null
}

// before performing a command, make sure its Browser tab is Selected, and its Main Chrome Window is FFox's active window
function selectBrowserForCommand(command){
	var contentWindow = getWindowFromCommand(command)
	return contentWindow
}

initialContentBrowser = null

function setInitialContentBrowser(coscripterWindow) {
	initialContentBrowser = getCurrentContentBrowser(coscripterWindow)
	return initialContentBrowser
}

//	getCurrentContentBrowserBySlop
function getCurrentContentBrowserBySlop(aWindow) {
	// eventually keep track of browser changes
	// for now, just return the initialBrowser
	return initialContentBrowser
}


/*
//	getCurrentContentBrowserBySlop
function getCurrentContentBrowserBySlop(aWindow) {
	var mainChromeWindow = getMainChromeWindow(aWindow)
	if (!mainChromeWindow) return null
	var browsersElement = mainChromeWindow.document.getElementById("content")	// this XULElement has nodeName="tabbrowser"
	// browsersElement has browsers and contentDocument and contentWindow properties
	if (browsersElement) {
		var currentBrowser = browsersElement.mCurrentBrowser	// there is also a selectedBrowser property (which may be different??)
		var selectedBrowser = mainChromeWindow.gBrowser.selectedBrowser	// alternate approach
		if (currentBrowser != selectedBrowser) debug("getCurrentContentBrowser: the two ways are NOT the same")
	}
	if (browsersElement) return browsersElement.selectedBrowser
	return null
}
*/
///////////////////////////////

// I'd like to rename this to getContentWindow, since the word "current" usually means that you don't provide an argument
function getCurrentContentWindow(aWindow) {
	var mainChromeWindow = getMainChromeWindow(aWindow)
	if (!mainChromeWindow) return null
	var browsers
	if (mainChromeWindow.document) browsers = mainChromeWindow.document.getElementById("content")
	else if (mainChromeWindow.ownerDocument) browsers = mainChromeWindow.document.getElementById("content")
	if (browsers && browsers.selectedBrowser) return browsers.selectedBrowser.contentWindow
	return mainChromeWindow
}

function getContentWindow(aWindow) {
	return getCurrentContentWindow(aWindow)
}

// Returns the CoScripter window of the first chrome window that has a CoScripter window
function getCurrentCoScripterWindow() {
	var chromeWindows = listWindows()
	for (var i = 0; i < chromeWindows.length; i++) {
		var chromeWindow = chromeWindows[i]
		var coScripterWindow = getCoScripterWindow(chromeWindow)
		if (coScripterWindow != null) return coScripterWindow
	}
}

function getCurrentScratchSpaceUI() {
	if (getCurrentCoScripterWindow() && getCurrentCoScripterWindow().coscripter) return getCurrentCoScripterWindow().coscripter.scratchSpaceUI
	else return null
}

function getContentBrowser(contentWindow) {
	if ((contentWindow.tagName == "xul:browser") || (contentWindow.tagName == "browser") ) return contentWindow
	var windowWatcher = 	CC["@mozilla.org/embedcomp/window-watcher;1"].getService(CI.nsIWindowWatcher)
	/*
	if (!contentWindow) 
		debug("utils.getContentBrowser: contentWindow is NULL")
	else debug("utils.getContentBrowser: contentWindow is " + contentWindow.document.title)
	*/
	return windowWatcher.getChromeForWindow(contentWindow)
}

/*				THE MAIN COSCRIPTER WINDOWS
A screenshot of the various windows is at http://koala.almaden.ibm.com/wiki/index.php/Main_Koala_Windows

-----------------------
IMPORTANT NOTE:
	When Firefox is running, it may have more than one open window.  We call these toplevel Firefox windows the mainChromeWindows.  
	That is, windowMediator returns a list of mainChromeWindows.
	This coscripter-utils component implements generic functions for accessing the most important windows, browsers, and areas within a mainChromeWindow
	The functions defined here take "aWindow" as an argument.  "aWindow" can be any window or subwindow (e.g. a Content Window within a tab) in Firefox. 
	The functions return windows and browsers that reside within ** the same mainChromeWindow as aWindow **
-----------------------

sidebarBrowser:	u.getSidebarBrowser(aWindow) 
	The full area usable by an extension loaded into the sidebar
	It doesn't include the "sidebarHeader" ("CoScripter" and a close box)
	= mainChromeWindow.document.getElementById("sidebar") 

coscripterWindow:	u.getCoScripterWindow(aWindow) 
	The window for the entire CoScripter extension
	Its source is coscripter-sidebar.xul
	coscripter-sidebar.js & coscripter-sidebar-ui.js are loaded into this window
	= sidebarBrowser.contentWindow

procedureBrowser:		u.getProcedureBrowser(aWindow)
	The browser that contains the title and text of a procedure. When editing, it contains two separate Textareas for the title and the procedure.  
	When executing, the html containing the title and the formatted procedure is loaded directly into this browser.
	= coscripterWindow.document.getElementById("procedureBrowser") 
	= sidebarBrowser.contentDocument.getElementById("procedureBrowser")

procedureStepArea:	u.getProcedureStepArea(aWindow)
	When editing, this is the Textarea that contains the procedure steps
	= u.getNode("//textarea[@id='procedure_body']", doc)

-----------------

currentChromeWindow:	u.getCurrentChromeWindow()
	The mainChromeWindow that is currently frontmost

mainChromeWindow:	u.getMainChromeWindow(aWindow)
	The main window of the entire Firefox Browser.
	The browser-overlay is loaded here.  The coscripter object resides here.

currentContentBrowser:	u.getCurrentContentBrowser(aWindow)
	The browser in the tabbrowser that contains the currently viewed document

currentContentWindow:	u.getCurrentContentWindow(aWindow)
	Contains the currently viewed document.
	The contentWindow of the currentContentBrowser
*/

// End window accessors
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
// Functions to access and manipulate the CoScripter sidebar
// ----------------------------------------------------------------------

/* Definitions:
// chromeWindow: the main firefox window in which you want to open a sidebar
// xulUrl: the chrome url of the xul file you want to load
// toggleViewId: the id that you'd usually pass to firefox's toggleSidebar function
// thenDoThis: a function to run after we've made sure the sidebar is open and loaded
//	 e.g. makeSidebarOpen(chromeWindow, "chrome://coscripter/content/sidebar.xul", "view-coscripter-wikiproc-prototype-sidebar", function() { alert("horray! it's open!") }))
// NOTE: even if the sidebar is already open, we'll still call *thenDoThis*
*/
function makeSidebarOpen(chromeWindow, xulUrl, toggleViewId, thenDoThis) {
    if (!isThisSidebarOpen(chromeWindow, xulUrl)) {
        var sidebar = getSidebar(chromeWindow)
        var handler = function() {
            sidebar.removeEventListener("load", handler, true)
            thenDoThis()
        }
        sidebar.addEventListener("load", handler, true)
        chromeWindow.toggleSidebar(toggleViewId)
    } else {
        thenDoThis()
    }
}

/* checks whether the given firefox main window has open the sidebar with the given chrome url
// e.g. isThisSidebarOpen(chromeWindow, "chrome://coscripter/content/sidebar.xul") */
function isThisSidebarOpen(chromeWindow, xulUrl) {
    if (isSidebarOpen(chromeWindow)) {
        return getSidebar(chromeWindow).getAttribute("src") == xulUrl
    } else {
        return false
    }
}

// sees if the given firefox main window has a sidebar open (we don't care what sort of sidebar it is at this point)
function isSidebarOpen(chromeWindow) {
    try {
        getSidebar(chromeWindow).contentDocument
        return true
    } catch (e) {
		dump('Error checking sidebar open status: ' + e + '\n');
        return false
    }
}

/* gets the sidebar parent node for the given firefox main window
// (note that this will always exist, even if there is no sidebar loaded into it) */
function getSidebar(chromeWindow) {
    return chromeWindow.document.getElementById("sidebar")
}

// ----------------------------------------------------------------------
// End sidebar accessors
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
// The Ident object
// This is used to parse slop into tokens
// ----------------------------------------------------------------------

// an extremely complete and comprehensive set of stop words for use in the "Ident" object below
var stopWords = {
    "your" : 1,
    "of" : 1,
    "in" : 1,
    "on" : 1,
}

// Ident stands for Identifier...
// This is a Constructor function.
//Whenever we want to see if two strings are sloppily similar, we create Idents for them and compare their Idents
// One of the strings will be a line in a CoScripter script which is about to be executed.
// The other string will be a list of all of the words -- generated by listCommands -- 
//that we feel might appear in a user-written command to perform a user action (e.g. click) 
//on a specific html element on the current web page.  
// This comparison is done in listCommands, which calls command.calcScore and passes it the ident for the CoScripter line,
//and another comparison is done in the bestSubString part of preUseWebElement
//So a good match between the Idents means that the command line in the CoScripter script 
//probably refers to this specific element on the current web page.
function Ident(string) {
    if (!string) {string = ""}
    this.string = string
    this.tokens = []
    this.tokenLocations = []
    RegExp.lastIndex = 0
    var a
    
    // JN: 6/6/2007
    // The following code sequence has been written previously using two different regular expressions:
    //    /([a-z]+|[A-Z]+[a-z]*|[0-9]|\S)/ig
    //    /(\S*)(\s+)/ig
    //
    // The current expression seems to work better because it handles special characters differently 
    // than alphanumerics while not supporting any particular configuration of alphanumerics (as the 
    // first regex did).
    //
    // The effect that this code has on the future execution is not immediately apparent, and you must
    // carefully test any changes to this code before being confident of a change.
	var r = /(\w+|\S)(\s*)/ig ; // needed to pull out the regex for FF 4.0 since the lastIndex property is not saved on a temporary object anymore ...
	while (a = r.exec(string)) { 
 		// e.g. when comparing "SomeString" and "some other string",  the "score" function will return 2,
		// since the strings have two tokens in common, namely "some" and "string"
		var token = a[1].toLowerCase()
		this.tokens.push(token)
		this.tokenLocations.push({
            start : RegExp.leftContext.length,
            end : (RegExp.leftContext.length + token.length),
        })
    }

    this.set = makeSet(this.tokens)
    
    this.score = function(that, wordsUsed) {
		// that.string is the slop
		// this.string is all of the words in the potential command for this html element
        var score = 0
        for (var word in this.set) {
            var thisScore = 0
            if (word.length >= 1 && !stopWords[word]) {
                thisScore = bagGet(that.set, word)
            } else {
                thisScore = bagGet(that.set, word) * 0.001
            }
            score += thisScore
            if (wordsUsed && (thisScore > 0.2)) {
                wordsUsed[word] = 1
            }
        }
        score -= 0.01 * this.tokens.length    // seems that this is penalizing textbox for having lots of synonyms in wordData (AC)
        return score
    }
    
    this.leftOver = function(startToken, endToken, insertString) {
        return this.subString(0, startToken) + insertString + this.subString(endToken, this.tokens.length)
    }
    
    this.subString = function(startToken, endToken) {
        if (startToken == endToken) {
            return ""
        } else {
            return this.string.substring(
                this.tokenLocations[startToken].start,
                this.tokenLocations[endToken - 1].end)
        }
    }
}

// End of Ident object
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
// Functions to load/save data to files in the filesystem
// ----------------------------------------------------------------------

// reads a file into a string
// (returns null if the file doesn't exist)
// adapted from: http://developer.mozilla.org/en/docs/Code_snippets:File_I/O#Reading_from_a_file
// license: MIT License
function readFile(file) {
    // |file| is nsIFile
    var data = "";
    var fstream = Components.classes["@mozilla.org/network/file-input-stream;1"]
                            .createInstance(Components.interfaces.nsIFileInputStream);
    var sstream = Components.classes["@mozilla.org/scriptableinputstream;1"]
                            .createInstance(Components.interfaces.nsIScriptableInputStream);
    try {
        fstream.init(file, -1, 0, 0);
    } catch (e) {
        return null
    }
    sstream.init(fstream); 
    
    var str = sstream.read(4096);
    while (str.length > 0) {
      data += str;
      str = sstream.read(4096);
    }
    
    sstream.close();
    fstream.close();
    return data
}

// file is nsIFile, data is a string
// adapted from: http://developer.mozilla.org/en/docs/Code_snippets:File_I/O#Reading_from_a_file
// license: MIT License
function saveString(file, data) {
    var foStream = Components.classes["@mozilla.org/network/file-output-stream;1"]
                             .createInstance(Components.interfaces.nsIFileOutputStream);
    
    // use 0x02 | 0x10 to open file for appending.
    foStream.init(file, 0x02 | 0x08 | 0x20, 0664, 0); // write, create, truncate
    foStream.write(data, data.length);
    foStream.close();
}

function saveImageToFile(canvas, file) {
	try {
		// THE FOLLOWING CODE COPY/PASTED FROM: 
		// http://developer.mozilla.org/en/docs/Code_snippets:Canvas
		// The canvas is converted to a PNG file and saved to the specified location
						
		// create a data url from the canvas and then create URIs of the source and targets  
		var io = Components.classes["@mozilla.org/network/io-service;1"]
		                   .getService(Components.interfaces.nsIIOService);
		var source = io.newURI(canvas.toDataURL("image/png", ""), "UTF8", null);
		var target = io.newFileURI(file)
		  
		// prepare to save the canvas data
		var persist = Components.classes["@mozilla.org/embedding/browser/nsWebBrowserPersist;1"]
		                        .createInstance(Components.interfaces.nsIWebBrowserPersist);
		
		persist.persistFlags = Components.interfaces.nsIWebBrowserPersist.PERSIST_FLAGS_REPLACE_EXISTING_FILES;
		persist.persistFlags |= Components.interfaces.nsIWebBrowserPersist.PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION;
		
		// save the canvas data to the file
		persist.saveURI(source, null, null, null, null, file);	
		
		return true;
	}
	catch(ex) {debug("saveImageToFile error: " + ex)}
	return false;
}


// ----------------------------------------------------------------------
// End file load/save functions
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
// String utility functions
function stringContains(string, subString) {
	return (string.search(RegExp(subString, "i")) != -1)
}

// eg "Functional<br>Design<br>" ==> "Functional Design "
function htmlSpaces(str) {
	var newStr = ""
	if (str) {
		newStr = str.replace(/<br>/ig, " ")
		return newStr
	} else {
		return str;
	}
}


function trimAndStrip(str) {
	return trim(stripSpaces(str));
}

// trim("  blah   ") == "blah"
function trim(str) {
	if (str) {
		return str.replace(/^\s*|\s*$/g, "")
	} else {
		return str;
	}
}

// Counts the number of words longer than 3 letters
function wordCount(str) {
	var wordExp = /\s*(w+)/g
	var wordMatch
	var count = 0
	while (wordMatch = wordExp.exec(str)){
		if (wordMatch[1].length > 3) count++
	}
	return count
}

// Compare two strings, ignoring any differences in spaces
function equalSpaceNormalized (string1, string2) {
	if (typeof string1 != "string" || typeof string2 != "string") return false
	var str1 = string1.replace(/\s+/ig," ")
	var str2 = string2.replace(/\s+/ig," ")
	return str1 == str2
}

function stripSpaces(s) {
	if (s) {
		var ret = s.replace(/&nbsp;/g, " ");
		ret = ret.replace(/\s+/g, " ");
		return ret;
	} else {
		return s;
	}
}

function numericP(str) {
	return (!isNaN(parseInt(str)))
}

// Takes an integer and returns a string with at least 2 digits, e.g. 05
function twoDigit(integer) {
	if (integer < 10) return "0" + integer
	return integer
}

// Takes an integer and returns a string with at least 3 digits, e.g. 005
function threeDigit(integer) {
	if (integer < 10) return "00" + integer
	if (integer < 100) return "0" + integer
	return integer
}

// Takes an integer and returns a string with at least 6 digits, e.g. 000005
function sixDigit(integer) {
	if (integer < 10) return "00000" + integer
	if (integer < 100) return "0000" + integer
	if (integer < 1000) return "000" + integer
	if (integer < 10000) return "00" + integer
	if (integer < 100000) return "0" + integer
	return integer
}

function stringDiff(string1, string2) {
	
}

// Given two multi-line strings, find the mid-section where they differ
function multiLineDiff(string1, string2) {
	string1 = stripTrailingNewlines(string1)
	string2 = stripTrailingNewlines(string2)
	var array1 = string1.split('\n')
	var array2 = string2.split('\n')
	
	// find first differing line
	var i = 0
	while(i < array1.length && array1[i] == array2[i]) i++
	var diffStartIndex = i
	// find last differing line
	i = 0
	while(i < array1.length && array1[array1.length-1 - i] == array2[array2.length-1 - i]) i++
	var diffEndIndex = i
	
	var diffLines1 = array1.slice(diffStartIndex, array1.length - diffEndIndex)
	var diffLines2 = array2.slice(diffStartIndex, array2.length - diffEndIndex)
	return [diffLines1, diffLines2, diffStartIndex, diffEndIndex, array1.length, array2.length]
}

function stripTrailingNewlines(theString) {
	var lastCharIndex = theString.search(/.\s*$/)
	newString = theString.slice(0, lastCharIndex+1)
	return newString
}

function endswith(str, suffix) {
	return str.slice(str.length - suffix.length, str.length) == suffix;
}

// End string utility functions
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
// Utility functions for documents and nodes

// returns the document associated with the given *thing* using a number of common methods
function getDocument(thing) {
    try
    {
        if (thing.documentElement) return thing
        if (thing.ownerDocument) return thing.ownerDocument
        if (thing.document) return thing.document
        if (thing.contentDocument) return thing.contentDocument
        
        return null;
    }
    catch(exc)
    {
        return null;
    }
}


// Functions to take a snapshot of a page
function takeSnapshotOfPage(contentWindow, canvasName, aroundRect){
    try {
        var scrollX = contentWindow.scrollX;
        var scrollY = contentWindow.scrollY;
        var innerWidth = contentWindow.innerWidth
        var innerHeight = contentWindow.innerHeight
        
        /*
         //var doc = browser.contentDocument;
         var contentWindow = doc.parent.contentWindow
         if (!doc || !doc.parent || !doc.parent.contentWindow)
         return false;
         if (doc && doc.documentElement != null) {
         // take the screenshot
         var x = doc.documentElement.offsetLeft;
         var y = doc.documentElement.offsetTop;
         var w = doc.documentElement.offsetWidth;
         var h = doc.documentElement.offsetHeight;
         var right = x + w
         var bottom = y + h
         //debug("takeSnapshotOfPage doc is " + x + "," + y + "," + w + "," + h + ", right is " + right + ", bottom is " + bottom)
         
         // Assume x and y are 0, and w and h are the document's w and h
         if (aroundRect) {  // just snapshot an area around this rect
         var xMargin = 80
         var yMargin = 120
         
         x = Math.max(0, aroundRect.x - xMargin)
         y = Math.max(0, aroundRect.y - yMargin)
         var snapRight = Math.min(right, aroundRect.x + aroundRect.w + xMargin)
         var snapBottom = Math.min(bottom, aroundRect.y + aroundRect.h + yMargin)
         w = snapRight - x
         h = snapBottom - y
         //debug("takeSnapshotOfPage aroundRect is " + aroundRect.x + "," + aroundRect.y + "," + aroundRect.w + "," + aroundRect.h)
         //debug("takeSnapshotOfPage snapRect is " + x + "," + y + "," + w + "," + h + ", snapRight is " + snapRight + ", snapBottom is " + snapBottom)
         }
         */
        if (!canvasName) 
            canvasName = "offscreen"
        var canvas = getSidebarElement(getCurrentCoScripterWindow(), canvasName)
        if (aroundRect) {
            var canvasWidth = aroundRect.w + 80
            var canvasHeight = aroundRect.h + 80
        }
        else {
            canvasWidth = innerWidth
            canvasHeight = innerHeight
        }
        canvas.setAttribute("width", canvasWidth)
        canvas.setAttribute("height", canvasHeight)
        
        var ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.save();
        
        if (aroundRect) {
            ctx.drawWindow(contentWindow, aroundRect.x - 40, aroundRect.y - 40, aroundRect.w + 80, aroundRect.h + 80, "rgb(255,255,255)");
        }
        else {
            ctx.drawWindow(contentWindow, scrollX, scrollY, innerWidth, innerHeight, "rgb(255,255,255)");
        }
        ctx.restore();
        
        return canvas;
    } 
    catch (ex) {
        debug("takeSnapshotOfPage error: " + ex)
    }
    return false;
}


//		NodeUtility
/**
 * NodeUtility provides methods for nodes.
 */

/**
 * From: http://webfx.eae.net/dhtml/mozInnerHTML/mozInnerHTML.js
 * Licensed under the Apache License, Version 2.0
 * Available at http://www.apache.org/licenses/LICENSE-2.0
 * THE CODE HAS BEEN CHANGED
 *   1) IT IS PART OF THE NodeUtility OBJECT, rather than being added to the HTMLElement OBJECT prototype
 *   2) in getOuterHTML, node.innerHTML IS USED INSTEAD OF getInnerHTML(node)
 *   3) in getOuterHTML, this.isLeafElem(node.nodeName) IS USED INSTEAD OF leafElems[node.nodeName]
 */

var NodeUtility = {	
	_isLeafElems : null,
	
	/**
	 * Returns whether the nodeName is a leaf node.
	 */
	isLeafElem : function(nodeName) {
		if (this._isLeafElems == null) {
			var leafElems = ["IMG", "HR", "BR", "INPUT"];
			this._isLeafElems = {};
			for (var i = 0; i < leafElems.length; i++) {
				this._isLeafElems[leafElems[i]] = true;
			}
		}
		
		return this._isLeafElems[nodeName];
	},
	
	/**
	 * Returns the actual HTML of the node (not just the inner HTML).
	 * From: http://webfx.eae.net/dhtml/mozInnerHTML/mozInnerHTML.js
	 */
	getOuterHTML : function(node) {
		var str = "";

		switch (node.nodeType) {
			case 1: // ELEMENT_NODE
				str += "<" + node.nodeName;
				for (var i=0; i<node.attributes.length; i++) {
					if (node.attributes.item(i).nodeValue != null) {
						str += " "
						str += node.attributes.item(i).nodeName;
						str += "=\"";
						str += node.attributes.item(i).nodeValue;
						str += "\"";
					}
				}

				if (node.childNodes.length == 0 && this.isLeafElem(node.nodeName))
					str += ">";
				else {
					str += ">";
					str += node.innerHTML; //getInnerHTML(node);
					str += "</" + node.nodeName + ">"
				}
				break;

			case 3: // TEXT_NODE
				str += node.nodeValue;
				break;

			case 4: // CDATA_SECTION_NODE
				str += "<![CDATA[" + node.nodeValue + "]]>";
				break;

			case 5: // ENTITY_REFERENCE_NODE
				str += "&" + node.nodeName + ";"
				break;

			case 8: // COMMENT_NODE
				str += "<!--" + node.nodeValue + "-->"
				break;
		}

		return str;
	},
	
	/**
	 * Returns the XPath of the given node.
	 */
	getXPath : function(node, useIds, foundId) {
		return XPathBuilder.buildXPathForNode(node, useIds, foundId);
	},
	
	/**
	 * Returns the location of the node on the screen.
	 */
	getLocation : function(element) {
		// Calculate the x and y positions of the clip.
		var x = element.offsetLeft;
		var y = element.offsetTop;
		
		var parent = element.offsetParent;
		while (parent != null && parent != element.ownerDocument) {
			x += parent.offsetLeft;
			y += parent.offsetTop;
			parent = parent.offsetParent;
		}
		
		var parent = element.parentNode;
		while (parent != null && parent != element.ownerDocument.body) {
			if (parent.scrollTop)
				y -= parent.scrollTop;
				
			if (parent.scrollLeft)
				x -= parent.scrollLeft;
				
			parent = parent.parentNode;
		}
		
		return [x, y];
	},
	
	/**
	 * Returns the size of the node on the screen.
	 */
	getSize : function(element) {
		var w = element.offsetWidth;
		var h = element.offsetHeight;
		
		return [w, h];
	}
}

///////////////////////
// XPath functions
///////////////////////

// returns an object with the XPath evaluate method that works on the document
function getDocumentWithEvaluate(thing) {
	try
	{
		var doc = getDocument(thing);
		if (doc != null)
		{
			doc = doc.QueryInterface(Components.interfaces.nsIDOMXPathEvaluator);
		}
		if (!doc || !doc.nodeName || doc.nodeName != "#document" || !("evaluate" in doc)) throw new Error("ERROR! In coscripter-utils, getDocumentWithEvaluate's doc isn't a doc");
		return doc;
	}
	catch(exc)
	{
		return null;
	}
}

function getXPath(node) {
        var pathString = ""
        while (node.parentNode) {
            pathString = countSameTypePriorSiblings(node) + pathString
            node = node.parentNode
        }
        return pathString
}

// Calculate the XPath from the node with an id that is closest to the leaf
//			getIdXPath
// Taken from contextRecorder.js
function getIdXPath(target) {
	var doc = target.ownerDocument
	var targetXPath = getXPath(target)
	var idAncestorList = getNodes("ancestor-or-self::*[@id]", target)
	if (!idAncestorList) return targetXPath	//no id node, use full xPath
	idAncestorList = idAncestorList.reverse()
	for (var i=0; i<idAncestorList.length; i++) {
		//Don't rely on the ID if it isn't unique
		var idNode = idAncestorList[i]
		var idName = idNode.getAttribute("id")
		var sameIdList = getNodes("//*[@id='" + idName + "']", doc)
		if (sameIdList.length == 1) break
		idNode = null
	}
	if (!idNode) return targetXPath	//no id node, use full xPath
	
	var xPathToIdNode = getXPath(idNode)
	var idXPath = "//*[@id='" + idName + "']" + targetXPath.slice(xPathToIdNode.length, targetXPath.length)
	return idXPath
}

    
function countSameTypePriorSiblings(node) {
   //returns the appropriate xPath string
    var originalNodeName = node.nodeName
    var count = 1
    while (node.previousSibling) {
		node = node.previousSibling
		if (node.nodeName == originalNodeName) count++
    }
	// kludge for http://pokl22wam.pok.ibm.com/wac/Controller?action=root
	//where HTML's previous sibling has name HTML instead of html
	//because source starts with <!DOCTYPE HTML ...  instead of <!DOCTYPE html ...
	if (originalNodeName == "HTML") count=1  
    return "/" + originalNodeName + "[" + count + "]"
}

// returns the node matching the given *xpath* rooted at *root*
function getNode(xpath, root) {
	if (!root) return null
	var nodesList = getNodes(xpath, root)
	if (nodesList && nodesList.length>0) return nodesList[0]
	return null
}

// returns an arrary of all the nodes, in dom order, that match the given *xpath* rooted at *root*
function getNodes(xpath, root) {
 	if (!root) return null
   var nodes = []
    getNodesHelper(xpath, root, nodes)
    return (nodes.length>0) ? nodes : null
}
function getNodesHelper(xpath, root, nodes) {
	try {
		var doc = getDocumentWithEvaluate(root)
		if (!doc || !doc.nodeName || doc.nodeName != "#document" || !("evaluate" in doc)) {
			debug("ERROR in coscripter-utils: getNodesHelper's doc isn't a doc")
		}
		// CD 4/1/08
		// sometimes a window object gets passed in here for reasons I
		// don't understand. For now I make sure  
		// to get the document for that window object.

		var rootDocument = (null!=root.document)?root.document:root ;
		var matchingNodes = doc.evaluate(xpath, rootDocument, null, 5, null)	//5 is ordered
		var matchingNode = matchingNodes.iterateNext()
		while (matchingNode) {
			nodes.push(matchingNode)
			matchingNode = matchingNodes.iterateNext()
		}
	}
	catch(exc) {
		debug("ERROR! getNodesHelper's doc isn't a doc: " + exc) 
		return null
	}
}


// removes all the children of the given node
function removeAllChildren(node) {
    while (node.firstChild) {
        node.removeChild(node.firstChild)
    }
}

// gets the node that you would find just below this node,
// if you were looking at a tree-view of the DOM (that didn't show closing tags, of course)
function nextNode(node) {
    if (node && node.firstChild) {
        return node.firstChild
    } else {
        while (node && !node.nextSibling) {
            node = node.parentNode
        }
        if (node) {
            return node.nextSibling
        }
    }
}

// gets the node that you would find just above this node,
// if you were looking at a tree-view of the DOM (that didn't show closing tags, of course)
function previousNode(node) {
    if (node.previousSibling) {
        node = node.previousSibling
        while (node.lastChild) {
            node = node.lastChild
        }
        return node
    } else {
        return node.parentNode
    }
}

// Get the NEAREST ancestor with the specified node name
// xpath uses DOM order, so we need the last match
function getAncestorNamed(node, name) {
	var ancestorList = getNodes("ancestor-or-self::" + name + "[1]", node)
	return ancestor = ancestorList ? ancestorList.pop() : null
}

// Get the NEAREST ancestor with the specified node name
// Explicitly looks at nodeName, since I can't get XPaths to work for xul nodes (AC)
function getAncestorByNodeName(node, name) {
	if (node.nodeName == name) return node
    while (node.parentNode) {
        node = node.parentNode
		if (node.nodeName == name) return node
    }
	return null
}

// Get the NEAREST ancestor with the specified ID
// xpath uses DOM order, so we need the last match
function getAncestorWithId(node, id) {
	var ancestorList = getNodes("ancestor::*[@id='" + id + "']", node)
    return ancestor = ancestorList ? ancestorList.pop() : null
}

function lowerCaseXPathFn(variable) {
	return "translate(" + variable + ", 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')";
}

function visibleP(element) {
	var win = element.ownerDocument.defaultView
	var parent = element
	do {
		var style = win.getComputedStyle(parent, null);
		var notVisible = (style.visibility == "hidden" || style.visibility == "collapse")
		var pos = getNodePosition(element);
		var noSize = (pos.x == 0 && pos.y == 0 && pos.w == 0 && pos.h == 0)
		if (notVisible || noSize || style.display == "none") return false;
	} while ((parent = parent.parentNode) && parent.nodeName != "#document")
	return true;
}

// Determine if the element is in a Table
//(where it could make sense to iterate over the rows)
function tableP(element) { 



}
	
// Determine if the element is in an html List
//(where it could make sense to iterate over the items)
function listP(element) { 
		// Look for the first parent li tag, then see if the enclosing ol or ul has at least 3 items
		var liElement = getAncestorNamed(element, "LI")
		if (!liElement) return false
		// Assume the ol or ul element is the parent of liElement. Not sure whether it could be an ancestor (AC) 
		var containingListElement = liElement.parentNode	// a ol or ul element
		if (!containingListElement || (containingListElement.tagName != "UL" && containingListElement.tagName != "OL")) return false
		
		
		
		

}


//////////////////////
//////////////////////
//	Dojo
//////////////////////
//////////////////////

//	getDojoWidgetNode
// When recording, getDojoWidgetNode finds the appropriate parent node which is the widget
function getDojoWidgetNode(node) {
	var doc = getDocumentWithEvaluate(node)
	var dojoParent = null
	var wairole = null
	var targetSpec = null
	
	// Check all of the custom widget types we can identify
	targetSpec = getDijitNode(node)
	/*
	// look for an ARIA wairole (non-presentation)
	dojoParent = doc.evaluate('ancestor-or-self::*[@wairole != "presentation"]', node, null, 9, null ).singleNodeValue
	if (dojoParent) wairole = dojoParent.getAttribute("wairole")
	return [dojoParent, wairole]
	*/

	return targetSpec
}

//	findDojoWidgetTargets
// When executing, findDojoWidgetTargets finds all of the nodes that match the command's target
function findDojoWidgetTargets(command, doc) {
	var label = command.getTargetLabel()
	var action = command.getAction();
	var targetType = command.getTargetType();
	var ordinal = null

    var targets = []
	var target = null
	
	// We have to decide whether to filter out targets that aren't visible.
	// For now, since we can't mouseover parents -- which is sometimes necessary to make a target visible --
	//I'm leaving this out (AC)
	
    // Find targets for custom widget types
    var dijitTargets = findDijitTargets(label, targetType, action, doc)
	if (dijitTargets.length > 0) return dijitTargets;
	
    return targets
}



//////////////////////
//		Dijits
//////////////////////
function getDijitNode(node) {	
	// Dijits get tagged by addDojoListeners in browser-overlay
    var doc = getDocumentWithEvaluate(node)
	var widgetClass = ""
	var widgetType = ""
	var targetType = ""
	var classString = ""
	var targetNode = null
	var labelNode = null
	var dijitParentList = null
	
    var dijitParents = doc.evaluate('ancestor-or-self::*[@CoScripterDijitClass]', node, null, 5, null ) // dojo onChange widgets
	var dijitParent = iteratorToList(dijitParents).pop()
    if (!dijitParent) {
		dijitParents = doc.evaluate('ancestor-or-self::*[contains(@class,"dijitTab")]', node, null, 5, null )
		dijitParentList = iteratorToList(dijitParents)
		var possibleParent = null
		while (possibleParent = dijitParentList.pop()) {
			classString = possibleParent.getAttribute("class")
			// the class must contain the word "dijitTab", and not, for instance, "dijitTabInnerDiv"
			if (classString.match(/dijitTab\b/)) {
				dijitParent = possibleParent
				break;
			}
		}
		if (dijitParent) {
			//labelledBy = getNodeByXPath('descendant-or-self::*[@role="tab"]', dijitParent, doc)
	    	//dijitLabel = labelledBy ? labelledBy.textContent : null
			// do I need to use this ^^ label code, or is it handled by the generic labelledBy code below?
			widgetClass = "dijit.layout.TabButton"
	        targetType = "tab"	
			
			// there may be a Close Button nested within the Tab
			if (node.getAttribute("statemodifier") == "CloseButton") {
				widgetClass = "dijit.layout.TabButton.CloseButton"
		        targetType = "closebutton"
			}
		}
	}
    if (!dijitParent) {
        dijitParent = doc.evaluate('ancestor-or-self::*[contains(@class,"dijitAccordionTitle")]', node, null, 9, null ).singleNodeValue
		if (dijitParent) targetNode = dijitParent
        widgetClass = "dijit.layout.AccordionTitle"
        targetType = "section"
    }
    if (!dijitParent) {
        dijitParent = doc.evaluate('ancestor-or-self::*[contains(@class,"dijitTitlePaneTitle")]', node, null, 9, null ).singleNodeValue
		if (dijitParent) targetNode = dijitParent
        widgetClass = "dijit.TitlePaneTitle"
        targetType = "section"
    }
    if (!dijitParent) {
        dijitParents = doc.evaluate('ancestor-or-self::*[contains(@class,"dijitTreeNode")] | ancestor-or-self::*[@class="dojoTreeNode"] | ancestor-or-self::*[@class="dojoTreeContent"] | ancestor-or-self::*[@class="dijitTreeContent"]', node, null, 5, null )
		dijitParent = iteratorToList(dijitParents).pop()
		//if (dijitParent) debug("dijitParent is a tree node: " + dijitParent.toString())
		// WEBi gets Caught exception: "[Exception... "An attempt was made to use an object that is not, or is no longer, usable" code: "11" nsresult: "0x8053000b (NS_ERROR_DOM_INVALID_STATE_ERR)" location: "x-jsd:interactive-session Line: 1"]"
        // maybe this is just caused by stepping with Venkman (AC)
		//dijitParent = doc.evaluate('ancestor-or-self::*[contains(@class,"dijitTreeNode")] | ancestor-or-self::*[@class="dojoTreeNode"]', node, null, 9, null ).singleNodeValue
        widgetClass = "dijit.TreeNode"      
        targetType = "item"
    }
    if (!dijitParent) {
        dijitParents = doc.evaluate('ancestor-or-self::*[contains(@class,"dijitMenuItem")]', node, null, 5, null )
        dijitParent = iteratorToList(dijitParents).pop()
        widgetClass = "dijit.MenuItem" 
        targetType = "menuitem"
    }
    if (!dijitParent) {
        dijitParents = doc.evaluate('ancestor-or-self::*[contains(@class,"dijitColorPalette")]', node, null, 5, null )
        dijitParent = iteratorToList(dijitParents).pop()
        widgetClass = "dijit.ColorPalette" 
        targetType = "color"
    }
    if (!dijitParent) {
		// clicks on elements within the DateTextBox should be ignored.  We just record the onChange at the end.
        dijitParents = doc.evaluate('ancestor-or-self::*[contains(@class,"dijitPopup")]', node, null, 5, null )
        dijitParent = iteratorToList(dijitParents).pop()
        widgetClass = "dijit.Popup"
        targetType = "ignore"
    }
	if (!dijitParent) return null;
	
	var commands = getCommands()
	var targetSpec = new commands.DojoWidgetTargetSpec()
	targetSpec.action = "click"
	
	if (!widgetClass) widgetClass = dijitParent.getAttribute("CoScripterDijitClass")  // e.g. "dijit.form.CurrencyTextBox"
                                                                        // the value of the node's dojotype parameter or the widget.declaredClass
	if (!widgetType) widgetType = widgetClass.slice(widgetClass.lastIndexOf(".")+1) // e.g. "CurrencyTextBox"
	
	// This is poor code, because it can generate targetTypes that we don't know about and haven't handled (AC)
	// e.g. the Connections "+" Add Tag widget
	// They can get past the "if (!dijitParent)" test above 
	//when CoScripterDijitClass has been added to the content page by our customEventListener in browser-overlay
	// It would take a large rewrite to fix this.
	if(!targetType) targetType = widgetType.toLowerCase()  // e.g. "button"
    if (widgetType.indexOf("Text") != -1
        || inArrayP(widgetType, ["NumberSpinner", "FilteringSelect", "ComboBox"])
       ){
        targetType = "textbox"
        node.setAttribute("targetType", "textbox")    // so getLabel can use its textbox labeler
        // getLabeler().TextBoxLabeler.getBestLabelFor(node)
		// 
		// Clicks on numberSpinner arrows are considered edits, and the new value is not committed until Focus is lost.
		//Therefore, the arrow clicks should be ignored until we record multiple interpretations (eg all keypresses)
		if (node.getAttribute("class") && node.getAttribute("class").indexOf("Arrow") != -1) targetType = "ignore"
    }
    
    if (widgetType != "TabButton" && widgetType.lastIndexOf("utton") == widgetType.length-5) {
        targetType = "button"
        //node.setAttribute("targetType", "button")    // so getLabel can use its button labeler
    }
	
	
	// Find the label
	if (widgetType == "TabButton"){
        targetSpec.targetLabel = node.textContent
        targetSpec.action = "click"
    }
    else if (widgetType == "ComboButton"){
        targetSpec.targetLabel = node.textContent
        targetSpec.action = "click"
		if (node.getAttribute("popupactive") != "true"){
            targetSpec.subcomponentName = "arrow"  //"button" is the default value
            targetSpec.subcomponentLabel = null    // e.g. "add Comment"
			targetSpec.subcomponentNode = node            
            labelledBy = doc.evaluate('descendant-or-self::*[@aria-labelledby]', dijitParent, null, 9, null ).singleNodeValue
            if (labelledBy) targetSpec.targetLabel = doc.getElementById(labelledBy.getAttribute("aria-labelledby")).textContent
		    targetType = "button"
		}
    }
    else if (widgetType == "AccordionTitle"){
        labelledBy = doc.evaluate('descendant-or-self::*[@dojoattachpoint="titleTextNode"]', dijitParent, null, 9, null ).singleNodeValue
        if (labelledBy) targetSpec.targetLabel = labelledBy.textContent
        targetSpec.action = "expand"
    }
    else if (widgetType == "TitlePaneTitle"){
        labelledBy = doc.evaluate('descendant-or-self::*[@dojoattachpoint="titleNode"]', dijitParent, null, 9, null ).singleNodeValue
        targetSpec.targetLabel = labelledBy.textContent
        targetSpec.action = ["collapse", "expand"]
        targetSpec.turnOnP = (dijitParent.getAttribute("class").indexOf("dijitClosed") != -1) ? true : false
    }
    else if (widgetType == "TreeNode"){
		labelledBy = getNodeByXPath('descendant-or-self::*[@dojoattachpoint="labelNode"]', dijitParent, doc)
		if (!labelledBy) labelledBy = getNodeByXPath('descendant-or-self::*[contains(@class,"dijitTreeLabel")]', dijitParent, doc)
        targetSpec.targetLabel = labelledBy.textContent
		targetSpec.action = "click"
        // expando subnode has class="dijitTreeExpando". Otherwise you're clicking the toplevel node.
        var expandoSubNode = doc.evaluate('descendant::*[contains(@class,"dijitTreeExpando")]', dijitParent, null, 9, null ).singleNodeValue
        if (expandoSubNode && node == expandoSubNode) {
	        targetSpec.action = ["collapse", "expand"]
	        targetSpec.turnOnP = (labelledBy.getAttribute("aria-expanded") == "false") ? true : false
		}
	}
    else if (widgetType == "Menu"){
        labelledBy = doc.evaluate('descendant-or-self::*[@dojoattachpoint="containerNode"]', node, null, 9, null ).singleNodeValue
        if (labelledBy) targetSpec.targetLabel = labelledBy.textContent
        targetSpec.action = "click"
        targetType = "menuitem"
   }
   else if (widgetType == "ColorPalette"){
        labelledBy = doc.evaluate('ancestor-or-self::*[@class="dijitPaletteCell"]', node, null, 9, null ).singleNodeValue
        if (labelledBy) targetSpec.targetLabel = labelledBy.getAttribute("title")
        targetSpec.action = "click"
   }
    else if (widgetType == "CloseButton"){
        labelledBy = doc.evaluate('descendant-or-self::a', dijitParent, null, 9, null ).singleNodeValue
        if (labelledBy) targetSpec.targetLabel = labelledBy.textContent
        targetSpec.action = "click"
        targetType = "closebutton"
   }
   
   else {	// look for an aria-labelledby attribute
	   	//var labelledBy = doc.evaluate('ancestor-or-self::*[@aria-labelledby]', node, null, 9, null ).singleNodeValue
		// need to get the match that is the closest ancestor of node
		var labelledBy = getNearestNodeByXPath('ancestor-or-self::*[@aria-labelledby]', node, doc)
		labelNode = labelledBy ? doc.getElementById(labelledBy.getAttribute("aria-labelledby")) : null
		if (labelledBy && !labelNode) {
			debug("ERROR in getDijitNode in getting ARIA label. labelledBy is defined but labelNode is not")
			return null
		}
	    if (labelledBy && labelNode){
			//debug("labelledBy and labelNode aren't null")
	        targetSpec.targetLabel = labelNode.textContent
			if (widgetType == "ToggleButton") {
	            targetSpec.action = ["turn off", "turn on"]
	            targetSpec.turnOnP = (dijitParent.getAttribute("class").indexOf("dijitToggleButtonChecked") != -1) ? false : true
			    targetType = "checkbox"
			}
	        if (widgetType == "Menu") {
				targetType = "menuitem"
			}
	    }
	}

	// fill in generic attributes for all dijits
    targetSpec.widgetClass = widgetClass
    targetSpec.widgetType = widgetType
    targetSpec.targetType = targetType
    targetSpec.widgetNode = dijitParent
	targetSpec.target = targetNode || node
	
	return targetSpec
}	// end of getDijitNode

function findDijitTargets(label, targetType, action, doc) {
	var relevantDijitClasses = []
	// either return targetSpecs, or add properties to the target nodes (AC)
	var buttonDijitClasses = []
	var textboxDijitClasses = ["ComboBox"]
	var dijitTargets = []
	
	var dijitIterator = null
	var dijitList = []
	var dijit = null
	var dijitLabel = ""
	var labelledBy = null
	var classString = ""
	var expandedP = false
	
	var newSubTarget = null
	var newTargetList = []
	
	// ComboBox
	if (targetType == "textbox"){
		dijitIterator = doc.evaluate('//*[@coscripterdijitclass="dijit.form.FilteringSelect"] | //*[@coscripterdijitclass="dijit.form.ComboBox"] | //*[@dojotype="dijit.InlineEditBox"]', doc, null, 5, null )
		// command-processor line 1312
		// target = coscripter.components.labeler().findTargetElement(currentContentWindow, command);
        dijitList = iteratorToList(dijitIterator)
		while (dijit = dijitList.pop()) {
            // get its label and check for a match
            dijitLabel = getLabeler().TextBoxLabeler.getBestLabelFor(dijit)
			if (dijitLabel == label) {
	            // get the input node
	            newSubTarget = doc.getElementById(dijit.getAttribute("widgetid"))
				newTargetList.push(newSubTarget)
			}
		}
	}

	// Checkbox
	if (targetType == "checkbox"){
		dijitIterator = doc.evaluate('//*[@coscripterdijitclass="dijit.form.ToggleButton"]', doc, null, 5, null )
        dijitList = iteratorToList(dijitIterator)
		while (dijit = dijitList.pop()) {
            // get its label and check for a match
			labelledBy = getNodeByXPath('descendant-or-self::*[@dojoattachpoint="containerNode"]', dijit, doc)
        	dijitLabel = labelledBy ? labelledBy.textContent : null
			if (dijitLabel == label) {
	            // get the input node
	            newSubTarget = doc.getElementById(dijit.getAttribute("widgetid"))
				newTargetList.push(newSubTarget)
			}
		}
	}

	// dijit.TreeNode
	if (targetType == "item"){
		dijitIterator = doc.evaluate('//*[contains(@class,"dijitTreeNode")] | //*[@class="dojoTreeNode"] | //*[contains(@class,"dojoTreeContent")] | //*[contains(@class,"dijitTreeContent")]', doc, null, 5, null )
        dijitList = iteratorToList(dijitIterator)
		while (dijit = dijitList.pop()) {
			// skip if it isn't visible
			if(!visibleP(dijit)) continue;	// ** this is needed for Cobra.  Eventually we'll handle this correctly in the general case (AC)
            // get its label and check for a match
			labelledBy = getNodeByXPath('descendant-or-self::*[@dojoattachpoint="labelNode"]', dijit, doc)
			if (!labelledBy) labelledBy = getNodeByXPath('child::*[contains(@class,"dijitTreeLabel")]', dijit, doc)
        	dijitLabel = labelledBy ? labelledBy.textContent : null
			if (dijitLabel == label) {
	            // get the sub node, based on the action
				// For now, I just want to get clicks working, and we're not always passing in the action yet (AC)
				// 	for a click:
				// old dojo nodes have onClick methods on a child 'titleNode:
				newSubTarget = getNodeByXPath('descendant-or-self::*[@dojoattachpoint="titleNode"]', labelledBy, doc)
	            if (!newSubTarget) newSubTarget = labelledBy
	            if (!newSubTarget) newSubTarget = dijit
				//	for an expando:
				if (action == "expandcollapse") newSubTarget = getNodeByXPath('preceding-sibling::*[contains(@class,"dijitTreeExpando")]', dijit, doc)
				// In dojo 1.3.2: <div class="dijitTreeNode"> <div> <span class="dijitTreeExpando"/><div class'"dijitTreeContent"><div/><span class="dijitTreeLabel" dojoattachpoint="labelNode"/>
				// so both the dijitTreeNode and the dijitTreeContent match as dijits. For the dijitTreeNode, the preceding-sibling fails, so skip it and use the dijitTreeContent match as the dijit.
				if (newSubTarget) {
					var subTargetClass = newSubTarget.getAttribute("class")
			        expandedP = (subTargetClass.indexOf("dijitOpen") != -1 || subTargetClass.indexOf("Opened") != -1) ? true : false
					newSubTarget.setAttribute("coscripterExpandedP", expandedP)
					newTargetList.push(newSubTarget)
				}
			}
		}
	}

	// dijit.layout.AccordionTitle and dijit.TitlePaneTitle
	if (targetType == "section"){
		dijitIterator = doc.evaluate('//*[contains(@class,"dijitAccordionTitle")] | //*[contains(@class,"dijitTitlePaneTitle")]', doc, null, 5, null )
        dijitList = iteratorToList(dijitIterator)
		while (dijit = dijitList.pop()) {
			classString = dijit.getAttribute("class")
			// class needs to contain the Word "dijitTab" or "dijitTitlePaneTitle".
			if (classString.match(/dijitTab\b/) || classString.match(/dijitTitlePaneTitle\b/)) {
	            // get its label and check for a match
				labelledBy = getNodeByXPath('descendant-or-self::*[@dojoattachpoint="titleTextNode"] | descendant-or-self::*[@dojoattachpoint="titleNode"]', dijit, doc)
				dijitLabel = labelledBy ? labelledBy.textContent : null
				if (dijitLabel == label) {
		            newSubTarget = dijit
			        expandedP = (dijit.getAttribute("class").indexOf("dijitOpen") != -1) ? true : false
					dijit.setAttribute("coscripterExpandedP", expandedP)
					newTargetList.push(newSubTarget)
				}
			}
		}
	}

	// dijit.layout.TabButton
	if (targetType == "tab"){
		dijitIterator = doc.evaluate('//*[contains(@class,"dijitTab")]', doc, null, 5, null )
        dijitList = iteratorToList(dijitIterator)
		while (dijit = dijitList.pop()) {
			classString = dijit.getAttribute("class")
			// class needs to contain the Word "dijitTab". Not e.g. "dijitTabInnerDiv"
			// classString.indexOf("dijitTab ") != -1 || classString.indexOf("dijitTab") + "dijitTab".length == classString.length)
			if (classString.match(/dijitTab\b/)) {
	            // get its label and check for a match
				labelledBy = getNodeByXPath('descendant-or-self::*[@role="tab"]', dijit, doc)
				dijitLabel = labelledBy ? labelledBy.textContent : null
				if (dijitLabel == label) {
		            newSubTarget = dijit
					newTargetList.push(newSubTarget)
				}
			}
		}
	}

	// dijit.layout.TabButton.CloseButton
	if (targetType == "closebutton"){
		dijitIterator = doc.evaluate('//*[contains(@class,"dijitTab")]', doc, null, 5, null )
        dijitList = iteratorToList(dijitIterator)
		while (dijit = dijitList.pop()) {
			classString = dijit.getAttribute("class")
			// class needs to contain the Word "dijitTab". Not e.g. "dijitTabInnerDiv"
			if (classString.match(/dijitTab\b/)) {
	            // get its label and check for a match
				labelledBy = getNodeByXPath('descendant-or-self::*[@role="tab"]', dijit, doc)
				dijitLabel = labelledBy ? labelledBy.textContent : null
				if (dijitLabel == label) {
					// found a dijitTab, now see if it has a closebutton
					var closebutton = doc.evaluate('descendant-or-self::*[@statemodifier="CloseButton"]', dijit, null, 9, null ).singleNodeValue
					if (closebutton){
			            newSubTarget = closebutton
						newTargetList.push(newSubTarget)
					}
				}
			}
		}
	}

	// dijit.Menu
	if (targetType == "menuitem"){
 		dijitIterator = doc.evaluate('//*[contains(@class,"dijitMenuItem")]', doc, null, 5, null )
       dijitList = iteratorToList(dijitIterator)
		while (dijit = dijitList.pop()) {
            // get its label and check for a match
			labelledBy = getNodeByXPath('descendant-or-self::*[contains(@class,"dijitMenuItemLabel")]', dijit, doc)
			dijitLabel = labelledBy ? labelledBy.textContent : null
			if (dijitLabel == label) {
	            // get the sub node, based on the action
				// For now, I just want to get clicks working, and we're not always passing in the action yet (AC)
				// 	for a click:
	            newSubTarget = dijit
				newTargetList.push(newSubTarget)
				//	for an expando:
			}
		}
	}

	// dijit.Editor
	if (targetType == "texteditor"){
		dijitIterator = doc.evaluate('//*[contains(@class,"RichTextEditable")]', doc, null, 5, null )
        dijitList = iteratorToList(dijitIterator)
		while (dijit = dijitList.pop()) {
            // get its label and check for a match
			labelledBy = getNodeByXPath('descendant-or-self::*[@aria-labelledby]', dijit, doc)
			labelNode = labelledBy ? doc.getElementById(labelledBy.getAttribute("aria-labelledby")) : null
			if (labelledBy && !labelNode) {
				debug("ERROR in findDijitTargets in getting button label. labelledBy is defined but labelNode is not")
			}
		    if (labelledBy && labelNode) dijitLabel = labelNode.textContent
			dijitLabel = labelledBy ? labelledBy.textContent : null
			if (label == null) dijitLabel = null	// sometimes we pick up a spurious dijitLabel, so if label == null, count it as a match
			if (dijitLabel == label) {	
	            // get the <body> of the <iframe> as the sub node
				var iframe = getNodeByXPath('descendant-or-self::IFRAME', dijit, doc)
				var contentDocument = iframe.contentDocument
				//var textContent = contentDocument.body.textContent
				newSubTarget = contentDocument.body
				if (newSubTarget) newTargetList.push(newSubTarget)
			}
		}
	}

	// Buttons
	if (targetType == "button"){
		dijitIterator = doc.evaluate('//*[@coscripterdijitclass="dijit.form.Button"] | //*[@coscripterdijitclass="dijit.form.DropDownButton"] | //*[@coscripterdijitclass="dijit.form.ComboButton"]', doc, null, 5, null )
        dijitList = iteratorToList(dijitIterator)
		while (dijit = dijitList.pop()) {
            // get its label and check for a match
			labelledBy = getNodeByXPath('descendant-or-self::*[@aria-labelledby]', dijit, doc)
			labelNode = labelledBy ? doc.getElementById(labelledBy.getAttribute("aria-labelledby")) : null
			if (labelledBy && !labelNode) {
				debug("ERROR in findDijitTargets in getting button label. labelledBy is defined but labelNode is not")
			}
		    if (labelledBy && labelNode) dijitLabel = labelNode.textContent
			if (dijitLabel == label) {
	            newSubTarget = dijit
				newTargetList.push(newSubTarget)
			}
			dijitLabel = ""
		}
	}

    return newTargetList
}	// end of findDijitTargets




/////////////////////////
//		Dojo Utilities
/////////////////////////
function hasDojoParentP(node) {
	var doc = getDocumentWithEvaluate(node)
	var dojoParent = null
	
	// look for an ARIA wairole (non-presentation)
	//dojoParent = doc.evaluate('ancestor-or-self::*[@wairole != "presentation"]', node, null, 9, null ).singleNodeValue
	// look for an ARIA wairole
	dojoParent = doc.evaluate('ancestor-or-self::*[@wairole]', node, null, 9, null ).singleNodeValue
	if (dojoParent) {
		var layoutParentP = dojoParent.getAttribute("class").indexOf("ayout") != -1	// ignore layout widgets, since they are not interactive (AC)
		if (!layoutParentP) return true
	}
	
	dojoParent = doc.evaluate('ancestor-or-self::*[contains(@class,"dijit ")]', node, null, 9, null ).singleNodeValue
	if (dojoParent) {
		return true
	}
	
	return false
}

function getNodeByXPath(xPathExpr, contextNode, doc) {
	var result = null
	var theNode = null
	try {
		result = doc.evaluate(xPathExpr, contextNode, null, 9, null )
		if (result) theNode = result.singleNodeValue
	}catch(e){
		debug('getNodeByXPath caused an exception: ' + e.toSource())
	}
	return theNode
}

// Gets a list of matches and returns the one closest to contextNode
function getNearestNodeByXPath(xPathExpr, contextNode, doc) {
	var result = null
	var theNode = null
	try {
		// 7 is ordered_node_snapshot_type
		result = doc.evaluate('ancestor-or-self::*[@aria-labelledby]', contextNode, null, 7, null )
		if (result.snapshotLength > 0) theNode = result.snapshotItem(result.snapshotLength-1)
	}catch(e){
		debug('getNearestNodeByXPath caused an exception: ' + e.toSource())
	}
	return theNode
}

function getDojoTextNode(node) {
	var doc = getDocumentWithEvaluate(node)
	var dojoTextNode = null

	dojoTextNode = doc.evaluate('descendant-or-self::*[contains(@class,"TextNode")]', node, null, 9, null ).singleNodeValue
	return dojoTextNode
}

//  Analogous to labeler's scoreAndAdd, but these candidates all match the targetLabel.
//  Given a command and a list of candidate matchingTargets that all match the targetType and targetLabel,
//use the ordinal to find the correct match.
//  Later, be able to use a disambiguating phrase to find the correct match.
function disambiguateMatchingTargets(command, matchingTargets) {		
	var ordinal = command.getOrdinal();
	var cardinal = getCardinal(ordinal);
	var lastIndex = matchingTargets.length-1
	
	// If no ordinal is specified; match the first target
	if (cardinal == null) return matchingTargets[lastIndex];
	
	// return the appropriate element of the array
	//return matchingTargets[lastIndex + 1 - cardinal]	// how could this have worked?? (AC)
	return matchingTargets[cardinal-1]
}


/*	Tessa's old code for generating Dojo labels
	// TL: try a different approach to generating cleaner Dojo labels
	if (node.hasAttribute('dojoattachpoint')) {
		return [node, "item"];
	}
	return [null, ""]

	// look for a parent with an onClick dojoattachevent
	dojoParents = doc.evaluate('ancestor-or-self::*[@dojoattachevent]', node, null, 0, null )
	dojoParent
	while (dojoParent = dojoParents.iterateNext()) {
		// if the dojoattachevent contains onClick:
		if (dojoParent && dojoParent.getAttribute("dojoattachevent")){
			var dojoEventString = dojoParent.getAttribute("dojoattachevent")
			//debug("dojoattachevent is " + dojoEventString)
			if (dojoEventString.indexOf("buttonClick") != -1) return [dojoParent, "button"]		
			if (dojoEventString.indexOf("onClick") != -1) return [dojoParent, "item"]
		}
	}

	// look for an element with a dojoattachpoint
	dojoParent = doc.evaluate('ancestor-or-self::*[@dojoattachpoint]', node, null, 9, null ).singleNodeValue
	// if the dojoattachpoint ....
	if (dojoParent && dojoParent.getAttribute("dojoattachpoint")){
		var dojoEventString = dojoParent.getAttribute("dojoattachpoint")
		if (true) return [dojoParent, "item"]
	}
	
	// look for a dojotype attribute
	dojoParent = doc.evaluate('ancestor-or-self::*[@dojotype]', node, null, 9, null ).singleNodeValue
//FIRST_ORDERED_NODE_TYPE
	if (dojoParent && dojoParent.getAttribute("dojotype")){
		var dojoTypeString = dojoParent.getAttribute("dojotype")
		var dojoNodeType = dojoTypeString.substring(dojoTypeString.lastIndexOf(".")+1)
		return [dojoParent, dojoNodeType.toLowerCase()]
	}
	
	return [null, ""]
*/

function getParentWithOnclick(node) {
	if (!node || !node.hasAttribute) return null;
	if (node && node.hasAttribute) {
		if (node.hasAttribute("onclick") || node.hasAttribute("mxevent")){	
		// (AC) mxevent is for maximo. If this works out, eventually add a section of maximo-specific methods
		// A typical UI element is <span mxevent="click" targetid="mx183" ev="PMCHGFSC"
		//	title="Change Implementation Schedule " style="display: block; cursor: pointer;" class="text favappsportletlink  ">
		//	so possibly look for a title, targetid, ev, class containing "link"
		return node;
		}
	}
	// TL: this may be the wrong test here
	if (node.parentNode == node || !node.parentNode) return null;

	return getParentWithOnclick(node.parentNode);
}

function listActionsAndTargetTypes(label, targetType, action, doc) {
	var actions = ["enter", "turn", "click", "expand", "collapse"]
	var targetTypes = ["textbox", "checkbox", "radiobutton", "button", "menuitem", "link", "tab", "section", "item"]
    return [actions, targetTypes]
}

/*	pairing widgetType and targetType
    var targets = 
           [{widgetType : "Button", targetType : "button"}, 
            {widgetType : "CheckBox", targetType : "button"},
            {widgetType : "ComboBox", targetType : "button"},
            {widgetType : "CurrencyTextBox", targetType : "button"},
            {widgetType : "DateTextBox", targetType : "button"},
            {widgetType : "FilteringSelect", targetType : "button"},
            {widgetType : "NumberSpinner", targetType : "button"},
            {widgetType : "NumberTextBox", targetType : "button"},
            {widgetType : "RadioButton", targetType : "button"},
            {widgetType : "TextBox", targetType : "button"},
            {widgetType : "TimeTextBox", targetType : "button"},
            {widgetType : "TabContainer", targetType : "button"},
            {widgetType : "Tree", targetType : "button"},
            {widgetType : "TitlePane", targetType : "button"},
            {widgetType : "ToggleButton", targetType : "button"},
            {widgetType : "AccordionContainer", targetType : "button"},
            {widgetType : "ComboButton", targetType : "button"},
            {widgetType : "DropDownButton", targetType : "button"},
            {widgetType : "Menu", targetType : "button"},
            {widgetType : "InlineEditBox", targetType : "button"},
            {widgetType : "MenuBar", targetType : "button"},
            {widgetType : "Form", targetType : "button"},
            {widgetType : "SimpleTextarea", targetType : "button"},
            {widgetType : "Textarea", targetType : "button"},
            {widgetType : "ValidationTextBox", targetType : "button"},
            {widgetType : "layout", targetType : "button"},
            {widgetType : "StackContainer", targetType : "button"},
            {widgetType : "ColorPalette", targetType : "button"}]
 */



//////////////////////
//	Xul
//////////////////////

//		getXulNode
// Called by getTargetAndType
function getXulNode(node, event) {
	if (node.namespaceURI != "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul") return null;
	var doc = getDocumentWithEvaluate(node)
	var commands = getCommands()
	var labeler = getLabeler()
	
	var originalTarget = event ? event.originalTarget : null
	var targetSpec = new commands.TargetSpec()
	var textValue = null	// the text to enter in a textbox or select in a listbox
	var widgetNode = null
	
	// ACTION
	var action = "click"
	
	// LABEL
	var label = node.label
	
	// TARGETTYPE
	var targetType = ""
	var nodeName = node.nodeName.toLowerCase()
	for (var webType in labeler.WEBTYPES) {	// e.g. webType=RADIOBUTTON, webTypeName="radiobutton"
		var webTypeName = labeler.WEBTYPES[webType]
		if (nodeName == webTypeName) targetType = webTypeName
	}
	switch(nodeName){
		case "radio" :
			targetType = "radiobutton"
			break;
		case "xul:button" :
			targetType = "button"
			break;
	}
	//if (node.id.indexOf("urn:mozilla:item:") != -1) targetType = "item"
	
	if (nodeName == "checkbox") {
        action = ["turn off", "turn on"]
        targetSpec.turnOnP = node.checked ? false : true
	}


	// BROWSWER PREFERENCES WINDOW
	// * click the "Content" tab in the "Preferences" window
	//    The click comes in with the target node being the window with node.id = "BrowserPreferences"
	//    The originalTarget has the radio (=tab) that was actually clicked.
	// * click the radio.label tab in the prefwindow.name window
	//if (node.control && node.control.id == "extensionsView") label = "Preferences"	// happens for Add-ons window
	//if (nodeName == "prefwindow") {
	if (node.id == "BrowserPreferences") {
		action = "click"
		label = originalTarget.label
		targetType = "tab"
	}
		
	// MENULIST
	// for a menulist(eg browserStartupPage)
	// * click the "When Firefox starts:" listbox in the "BrowserPreferences" window
	if (nodeName == "menulist") {
		action = "click"
		targetType = "menu"
		var listBoxLabelers = node.parentNode.getElementsByAttribute('control', node.id)
		label = (listBoxLabelers && listBoxLabelers[0]) ? listBoxLabelers[0].value : null
	}
	
	// MENUITEM
	// for a menuitem in a (menupopup in a) menulist(eg browserStartupPage)
	// * Select the "Show a blank page" item in the "When Firefox starts:" listbox in the "BrowserPreferences" window
	// * Select menuitem.label in the menuitem's menupopup's menulist
	// * Select menulist.label in the menulist's hbox has a label element with control = menulist's id and with value = "When Firefox starts:"
	if (nodeName == "menuitem") {
		action = "select"
		textValue = node.label
		targetType = "listbox"
		widgetNode = getAncestorByNodeName(node, "menulist")
		//widgetNode = doc.evaluate('ancestor-or-self::menulist', node, XulNSResolver, 9, null ).singleNodeValue
		//var aa = doc.evaluate('ancestor-or-self::*[@id]', node, XulNSResolver, 5, null )
		if (widgetNode) listBoxLabelers = widgetNode.parentNode.getElementsByAttribute('control', widgetNode.id)
		label = listBoxLabelers ? listBoxLabelers[0].value : null
	}
	
	/*	for a radio in a xul:radiogroup
	// for a radio in a xul:radiogroup
	widgetNode = doc.evaluate('ancestor-or-self::*[contains(nodeName, "radiogroup")]', node, null, 9, null ).singleNodeValue
	if (widgetNode) {
		action = "click"
		targetType = "button"
		var radioNode = doc.evaluate('ancestor-or-self::radio', node, null, 9, null ).singleNodeValue
		label = radioNode.label
	}
	*/	

	// RICHLISTITEM
	if (nodeName == "richlistitem") {
		label = node.getAttribute("name")
		targetType = "item"
		if (originalTarget && originalTarget.localName == "button"){
			label = originalTarget.label
			targetType == "button"
			if (event.type == "mousedown") {
				// this kludge lets command-generator's onClick method discard the mousedown event and just record the click event
				targetType = "ignore"	
			}
		} 
	}
	
	targetSpec.action = action
	targetSpec.targetType = targetType
	targetSpec.targetLabel = label
	targetSpec.textValue = textValue
	
	return targetSpec
}	// end of getXulNode

//		findXulTargets
function findXulTargets(command, document) {
	var targetWindow = getWindowFromCommand(command)
	var doc = targetWindow ? targetWindow.document : document
	if (!doc) return []
	if (!xulNodeP(doc)) return [];

	var label = command.getTargetLabel()
	var targetType = command.getTargetType()
	var action = command.getAction()
	var widgets = []
	var widget = null
    var targets = []
	var dialog = doc.documentElement
	var iterator = null
	var result = null
	
	// Include all elements with nodeName == targetType and matching label attribute
	// Works for checkbox
	widgets = doc.getElementsByAttribute('label', label)
	for (var i=0; i<widgets.length; i++) {
		widget = widgets[i]
		if (widget.nodeName == targetType){
			targets.push(widget)
		}
	}

	// RICHLISTITEM
	if (targetType == "item"){
		widgets = doc.getElementsByAttribute('name', label)
		for (var i=0; i<widgets.length; i++) {
			widget = widgets[i]
			targets.push(widget)
		}
	}

	// PREFPANE
	if (targetType == "tab"){
		widgets = doc.getElementsByAttribute('label', label)
		for (var i=0; i<widgets.length; i++) {
			widget = widgets[i]
			if (widget.nodeName == "prefpane"){
				targets.push(widget)
			}
		}
	}

	// TAB
	if (targetType == "tab"){

		widgets = doc.getElementsByAttribute('label', label)
		for (var i=0; i<widgets.length; i++) {
			widget = widgets[i]
			if (widget.nodeName == "radio"){
				targets.push(widget)
			}
		}
	}

	// RADIOBUTTON
	if (targetType == "radiobutton"){
		widgets = doc.getElementsByAttribute('label', label)
		for (var i=0; i<widgets.length; i++) {
			widget = widgets[i]
			if (widget.nodeName == "radio"){
				targets.push(widget)
			}
		}
	}

	/* experiments to try to access the tabs at the top of the FFox Preference window (AC) 
	result = doc.evaluate('//*[local-name()="button" and namespace-uri() = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"]', doc, null, 9, null ).singleNodeValue
	iterator = doc.evaluate('//*[local-name()="button" and namespace-uri() = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"]', doc, null, 5, null )
	if (iterator) result = iteratorToList(iterator)
	iterator = doc.evaluate('//*[local-name()="radio" and namespace-uri() = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"]', doc, null, 5, null )
	iterator = doc.evaluate('//*[local-name()="radio"]', doc, null, 5, null )
	iterator = doc.evaluate('//*[@nodeName="radio"]', doc, null, 5, null )
	iterator = doc.evaluate('*', doc, XulNSResolver, 5, null )
	iterator = doc.evaluate('*', doc, null, 5, null )
	iterator = doc.evaluate('*[@id]', doc, XulNSResolver, 5, null )
	*/
		
	/*	createTreeWalker 
	if (targetType == "tab"){	
		var radioChildren = []
		var radioChildrenNames = ""
		var radioChildrenLabels = ""
		const nsIDOMNodeFilter = Components.interfaces.nsIDOMNodeFilter;
		var iterator = doc.createTreeWalker(doc.documentElement,
		                                    0x00000001,	//nsIDOMNodeFilter.SHOW_ELEMENT,
		                                    _filterRadioGroup,
		                                    true);
		while (iterator.nextNode()) {
		  radioChildren.push(iterator.currentNode);
		  radioChildrenNames += iterator.currentNode.nodeName + ", "
		  radioChildrenLabels += iterator.currentNode.getAttribute("label") + ", "
		 }
	}

	function _filterRadioGroup(node){
		switch (node.localName) {
            case "script": return 2	//NodeFilter.FILTER_REJECT;
            default: return 1	//NodeFilter.FILTER_ACCEPT;
          }
	}
	*/

	/*	_filterRadioGroup
	function _filterRadioGroup(node){
		switch (node.localName) {
            case "radio": return 1	//NodeFilter.FILTER_ACCEPT;
            case "template":
            case "radiogroup": return 2	//NodeFilter.FILTER_REJECT;
            default: return 3	//NodeFilter.FILTER_SKIP;
          }
	}
	*/	

	//debug("radioChildrenNames: " + radioChildrenNames)
	//debug("radioChildrenLabels: " + radioChildrenLabels)



	// ITEM 
	// Accept anything as an item if its label matches. e.g. the "Preferences" button in the Add-ons window is called an item
	// Elements can get pushed on the list more than once.
	if (targetType == "item"){
		widgets = doc.getElementsByAttribute('label', label)
		//widgets = doc.getElementsByTagNameNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "button")
		//var result = doc.evaluate('//*[local-name()="button" and namespace-uri() = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"]', doc, null, 5, null);
		//var resultList = iteratorToList
		for (var i=0; i<widgets.length; i++) {
			widget = widgets[i]
			targets.push(widget)
		}
	}

	// standard dialog buttons
	//handle dialog's standard buttons specially
	var button = null
	if (targetType == "button") {
		var standardButtonNames = ["accept", "cancel", "help", "disclosure", "extra1", "extra2"]
		for (var i=0; i<standardButtonNames.length; i++) {
			if (dialog.getButton) button = dialog.getButton(standardButtonNames[i])
			if (button && button.label == label) targets.push(button)	
			// May want to check properties: disabled, collapsed, hidden
		}
	}
	
	if(command.targetSpec && command.targetSpec.targetType == "textbox") {
		/* Can't get getElementsByClassName or getElementsByTagName on dialog or doc to work
		var textboxes = dialog.getElementsByClassName("textbox-input")
		var textbox = (textboxes.length>0) ? textboxes.item[0] : null
		debug("# textboxes: " + textboxes.length)
		*/
		var textbox = doc.activeElement
		if (textbox && textbox.className == "textbox-input") targets.push(textbox)
		var pwdTextbox = doc.getElementById("password1Textbox") // kludge to handle w3 authentication dialogs (for coco) (AC)  
		if (pwdTextbox) targets.push(pwdTextbox)
	}

   return (targets.length > 0) ? targets : []
}	// end of findXulTargets

//		Xul utilities
function xulNodeP(node){
	//return ("boxObject" in node)
	if (node.namespaceURI == "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul") return true
	var docURI = ""
	if (node.documentURI) docURI = node.documentURI
	else {
		var doc = node.ownerDocument
		if (!doc) return false
		docURI = doc.documentURI
	}
	if (!docURI) return false
	var docURISuffix = docURI.slice(-3)
	if (docURISuffix == "xul") return true
	return false
}

function getXulWindow(node) {
	// not necessarily a window, but a xul element, like a dialog
	// From the xul tutorial: The dialog  element should be used in place of the window element when creating a dialog.
	if (!xulNodeP(node)) {
		debug("getXulWindow called on a non-xul node")
		return node
	}
	var childNode = node
	var parentBox = childNode.boxObject.parentBox
	while (parentBox != childNode) {	// could alternatively test for localName = "dialog"
		childNode = parentBox
		if (!xulNodeP(childNode)) {
			debug("getXulWindow called with a non-xul CHILD node")
			return node
		}
		parentBox = childNode.boxObject.parentBox
	}
	return parentBox
}

function getXulDocument(node) {
	if (node.documentURI && docURI.slice(-3) == "xul") return node
	var ownerDoc = node.ownerDocument
	if (ownerDoc && xulNodeP(ownerDoc)) return ownerDoc
	return getXulWindow(node).ownerDocument.documentElement
}

function XulNSResolver(prefix) {
  if(prefix == 'html') {
    return 'http://www.w3.org/1999/xhtml';
  }
  else if(prefix == 'xul') {
    return 'http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul'
  }
  else  {
  //this shouldn't ever happen
    return null;
  }
}


// End utility functions for documents and nodes
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
// XMLHttpRequest-oriented functions

function setCoScripterRequestHeaders(h,url){
	// set general headers for any coscripter http request

	// coscripter version
	h.setRequestHeader("COSCRIPTERVERSION" ,coscripterVersion())
	
	// authentication cookie (if exists)
	// this is not always set automatically, especially when the user
	// has turned off the "allow third party cookies" option in the cookie
	// security. 
	var cookieString = getAuthCookie(url);
	if(cookieString != null ){
		h.setRequestHeader("Cookie" ,cookieString);
	}
}

function httpRequest(url, method, variables, cb, errorCb, jsonDecode) {
	var h = CC["@mozilla.org/xmlextras/xmlhttprequest;1"].createInstance()
	var async = (cb != null)
	try {
		h.open(method, url, async)
		setCoScripterRequestHeaders(h, url);
		h.setRequestHeader("Content-Type", "application/x-www-form-urlencoded")
		var vars = []
		for (var v in variables) {
			var value = variables[v];
			// If value is an array
			if ((value != null) && (typeof value.length == "number") && (typeof value.splice == "function")) {
				for (var i = 0, n = value.length; i < n; i++) {
					vars.push(v + "=" + encodeURIComponent(value[i]))
				}
			}
			else {
				vars.push(v + "=" + encodeURIComponent(variables[v]))
			}
		}
		h.send(vars.join("&"))
		if (cb) {
			h.addEventListener("load", function(evt){
				if (h.status >= 200 && h.status < 300) {
					if (jsonDecode) {
						var data = JSON.parse(h.responseText);
						cb(true, h.status, data);
					}
					else {
						cb(true, h.status, h.responseText);
					}
				} else {
					cb(false, h.status, h.responseText);
				}
			}, false);
			h.addEventListener("error", function(evt){
				if (typeof errorCb == 'function') {
					errorCb(h.responseText, h.status);
				} else {
					cb(false, null, null);
				}
			}, false);
		}

		if (!async) return [h.status, h.responseText]
	} catch (e) {
		debug("post command failed in coscripter-utils")
		debug(e);
		return null
	}
}


// posts the given *variables* to the given *url*,
// e.g.     post("www.google.com", {
//              searchWord1 : "Koala",
//              searchWord2 : "Bear",
//          })
// NOTE: I don't think google accepts such a post request, but hopefully you get the idea
// Returns the HTTP response text, or null on failure
function post(url, variables, async) {
	var h = CC["@mozilla.org/xmlextras/xmlhttprequest;1"].createInstance()
    if (null == async) async = false
    try {
		h.open("POST", url, async)
		setCoScripterRequestHeaders(h,url);
		h.setRequestHeader("Content-Type", "application/x-www-form-urlencoded")
		var vars = []
		for (var v in variables) {
			vars.push(v + "=" + encodeURIComponent(variables[v]))
		}
		h.send(vars.join("&"))

		if (!async) return [h.status, h.responseText]
		// otherwise, it was asynchronous -- ignore the results
    } catch (e) {
		debug("post command failed in coscripter-utils")
		return null
    }
}

function getAuthCookie(url){
	var cookieMgr = Components.classes["@mozilla.org/cookiemanager;1"].getService(Components.interfaces.nsICookieManager);
	var ios = Components.classes["@mozilla.org/network/io-service;1"].getService(Components.interfaces.nsIIOService);
	var uri = ios.newURI(url, null, null);

	// CD: this should really work, but does not. Maybe a mozilla bug...
	//var cookieSvc = Components.classes["@mozilla.org/cookieService;1"].getService(Components.interfaces.nsICookieService);
	//var cookieString = cookieSvc.getCookieString(uri, null);
	
	// instead: crab the coscripter_session_id cookie out of the store and reassemble the cookie string
	var coscripterUrl = getKoalescenceURL();
	var coscripterServer = ios.newURI(coscripterUrl, null, null).host;
	for (var e = cookieMgr.enumerator; e.hasMoreElements();) {
		var cookie = e.getNext().QueryInterface(Components.interfaces.nsICookie);
		if(cookie.name == "coscripter_session_id" && cookie.host == coscripterServer){
			//dump(cookie.host + ";" + cookie.name + "=" + cookie.value + "\n");
			return cookie.name + "=" + cookie.value ;
		}
	}
	return null ;
}

// delete creates a delete request with the given variables to the given *url*,
// e.g.     deleteRequest("www.google.com", {
//              searchWord1 : "Koala",
//              searchWord2 : "Bear",
//          })
function deleteRequest(url, variables, async) {
	var h = CC["@mozilla.org/xmlextras/xmlhttprequest;1"].createInstance()
    if (null == async) {
		async = false;
    }
    try {
		h.open("DELETE", url, async)
		setCoScripterRequestHeaders(h,url);
		h.setRequestHeader("Content-Type", "application/x-www-form-urlencoded")
		var vars = []
		for (var v in variables) {
			vars.push(v + "=" + encodeURIComponent(variables[v]))
		}
		h.send(vars.join("&"))
	
		if (!async) {
		    return [h.status, h.responseText]
		}
		// otherwise, it was asynchronous -- ignore the results
    } catch (e) {
		debug("deleteRequest command failed in coscripter-utils")
	return null
    }
}

// This function loads a web page and returns the result as a string
// If the optional callback (cb) is specified, it will load the page
// asynchronously and call the callback with the page text on completion.
// If not specified, it will block until the page is loaded and return the
// page text.
function loadWebPage(url, cb, errorCb){
	var h = CC["@mozilla.org/xmlextras/xmlhttprequest;1"].createInstance()
	var async;
	if (cb) {
		async = true;
	} else {
		async = false;
	}
	h.open("get", url, async);
	setCoScripterRequestHeaders(h,url);	
	if (cb) {
		h.addEventListener("load", function(evt){
			cb(h.responseText)
		},false);
		h.addEventListener("error", function(evt){
			if (typeof errorCb == 'function') {
				errorCb(h.responseText, h.status);
			} else {
				cb(null);
			}
		},false);
	}
	h.send("");
	if (cb) {
		return;
	} else {
		return h.responseText;
	}
}

// This function loads a web page and returns the statuscode of the
// request, and the JSON object parsed from the server response.
// If the statuscode is positive, it is the HTTP status of the request.  If
// it's negative that means something went wrong earlier in the chain
// (e.g., host name not found).
// This function must work asynchronously.
function loadJSONWithStatus(url, cb) {
	try {
		var h = CC["@mozilla.org/xmlextras/xmlhttprequest;1"].createInstance();
		h.open("get", url, true);
		setCoScripterRequestHeaders(h,url);
		var data;

		h.addEventListener("load", function(evt){
			if (h.status >= 200 && h.status < 300){
				
				var data = JSON.parse(h.responseText);
		
				cb(true, h.status, data);
			} else {
				cb(false, h.status, h.responseText);
			}
		},false);
		h.addEventListener("error", function(evt){
			cb(false, -1, (h!= null &&h.responseText!=null)?h.responseText:null);
		},false);
		h.send(null);
	} catch (e) {
		d('Error in loadJSONWithStatus: ' + e + '\n');
	}
}

// returns the given *url* as an XML document object (assuming it contains xml data)
function loadWebPageXml(url, cb) {
	var h = CC["@mozilla.org/xmlextras/xmlhttprequest;1"].createInstance()
	var async;
	if (cb) {
		async = true;
	} else {
		async = false;
	}
	h.overrideMimeType("text/xml");
	h.open("get", url, async)
	setCoScripterRequestHeaders(h,url);
	h.onload = function(event) {
		cb(event.currentTarget.responseXML);
	}
	h.send("")
	if (cb) {
		return;
	} else {
		return h.responseXML;
    }
}

// Turn a string of the form "one=two&three=four" into a hash {'one':'two',
// 'three':'four'}
function parseQueryParameters(vars) {
	var hash = {};
	var params = vars.split('&');
	for (var i=0; i<params.length; i++) {
		var param = params[i];
		var parts = param.split('=', 2);
		var name = decodeURIComponent(parts[0]);
		var val = decodeURIComponent(parts[1]);
		hash[name] = val;
	}
	return hash;
}

// End XMLHttpRequest-oriented functions
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
// Highlight nodes in an HTML document

// makes sure the node is visible in whatever browser it is in,
// and returns true if it had to do some programmatic scrolling to achieve this goal
function ensureVisible(node) {
    var window = node.ownerDocument.defaultView
    var pos = getNodePosition(node)
    
    var x = window.scrollX
    var y = window.scrollY
    var w = window.innerWidth
    var h = window.innerHeight
    
    var margin = 100
    var scrolled = false
    
    if (pos.x < x) {
        scrolled = true
        x = pos.x - margin
    }
    if (pos.x + pos.w > x + w) {
        scrolled = true
        x = pos.x + margin + pos.w - w
    }
    if (pos.y < y) {
        scrolled = true
        y = pos.y - margin
    }
    if (pos.y + pos.h > y + h) {
        scrolled = true
        y = pos.y + margin + pos.h - h
    }
    
    window.scrollTo(x, y)
    return scrolled
}

// returns an object representing the *node*'s position (in client space),
// like: {
//      x : 100,
//      y : 57,
//      w : 64 // this is the width
//      h : 32 // this is the height
// }
function getNodePosition(node, options) {
    var pos = {}
	if (node.nodeName && node.nodeName.toLowerCase() == "body") {
        pos.x = 0
        pos.y = 0
        pos.w = 0
        pos.h = 0		
	// Special-case check for AREA nodes first
	} else if (node.nodeName == "AREA" && node.hasAttribute('coords') &&
		node.hasAttribute("shape") &&
		node.getAttribute("shape").toLowerCase() == "rect") {
		// It's a rectangular area in an imagemap ... pull out the coordinates
		var coords = node.getAttribute('coords').split(',');
		pos.x = parseInt(coords[0]) + node.offsetLeft;
		pos.y = parseInt(coords[1]) + node.offsetTop;
		pos.w = parseInt(coords[2]) - parseInt(coords[0]);
		pos.h = parseInt(coords[3]) - parseInt(coords[1]);
	} else if ("offsetLeft" in node) {
        pos.x = node.offsetLeft
        pos.y = node.offsetTop
        pos.w = node.offsetWidth
        pos.h = node.offsetHeight
        if (node.offsetParent != null) {
            var parentPos = getNodePosition(node.offsetParent)
            pos.x += parentPos.x
            pos.y += parentPos.y
        }
    } else if (xulNodeP(node)) { // XUL elements
        pos.x = node.boxObject.x
        pos.y = node.boxObject.y
        pos.w = node.boxObject.width
        pos.h = node.boxObject.height
    } else if (node.parentNode != null) {
        pos = getNodePosition(node.parentNode)
    } else {
        pos.x = 0
        pos.y = 0
        pos.w = 0
        pos.h = 0
    }
	
	// Calculate the position of a particular tree cell
	if (options) {
		if ("rowIndex" in options && "columnIndex" in options) {
			var tree;
			var treeBoxObject;
			try {
				tree = node.QueryInterface(Components.interfaces.nsIDOMXULElement);
				treeBoxObject = tree.boxObject.QueryInterface(Components.interfaces.nsITreeBoxObject);
			}
			catch (exc) {
				tree = null;
				treeBoxObject = null;
			}
			if (tree != null && treeBoxObject != null) {
				var x = {}, y = {}, width = {}, height = {};
				var part = "cell";
				treeBoxObject.getCoordsForCellItem(options.rowIndex, treeBoxObject.columns[options.columnIndex], part, x, y, width, height);
				pos = {x: pos.x + x.value, y: pos.y + y.value, w: width.value, h: height.value};
			}
		}
	}
    return pos
}


function isVisible(element){
	var pos = getNodePosition(element);
	return !(pos.x == 0 && pos.y == 0 && pos.w == 0 && pos.h == 0)
}

// want to make a node invisible? try setVisible(node, false)
function setVisible(node, on) {
    node.style.visibility = (on) ? "visible" : "hidden"
}

// sets a number of style options on the given *div* (which could really be any node),
// note that "o" is the opacity, and could be 0.01 for a super transparent node
function setDivStyle(div, x, y, w, h, o, color) {
    if (color == undefined) {
        color = "green"
    }
    div.style.position = "absolute"
    div.style.left = x + "px"
    div.style.top = y + "px"
    div.style.width = w + "px"
    div.style.height = h + "px"
    div.style.backgroundColor = color
    div.style.opacity = o
	// TL: this number has to be larger than the z-indices of
	// all other elements on the page
    div.style.zIndex = 99999
}

// creates a div with the given styles,
// NOTE: this will attach the div to document somewhere near the root,
// but it returns the div, so you can put it somewhere else if you like
function createDiv(node, x, y, w, h, o, color) {
	var doc = node;
 	if (xulNodeP(node)) {
		doc = getXulDocument(node)
	} else if (!node.documentElement) {
        doc = node.ownerDocument
	}
	
	try {
	    var div = doc.createElement("DIV")
	    setDivStyle(div, x, y, w, h, o, color)
		// (AC) Problem with xulDocument.documentElement.appendChild
		if (xulNodeP(node)) return div;
	    doc.documentElement.appendChild(div)
	    return div
	} catch(e) {
		debug('utils: exception in createDiv: ' +e.toSource() );
	}
}

//		highlightNode
// Creates a transparent box over the given *node*
// Returns the div so you can later remove it to remove the highlight-effect
function highlightNode(node, color, options) {
    if (node.tagName == "OPTION") node = node.parentNode
	if (!color) color = "red"
    
    var pos = getNodePosition(node, options)
    var div = createDiv(node, pos.x, pos.y, pos.w, pos.h, 0.5, color)
    div.setAttribute('id', ((node.id ? (node.id + '-') : '') + pos.x + '-' + pos.y + '-CoS-hilite-div'));	// This was Bad. It previously created a div with the Same Id as node (AC)
    return div;
}

function makeBigArrowHighlight(node) {
    if (node.tagName == "OPTION") {
        node = node.parentNode
    }

    var pos = getNodePosition(node)

	// These are the size (in pixels) of the "bubbles-top.png" image
	var bigarrowwidth = 330;
	var topheight = 101;
	var arrowboxleft = 22;	// offset of white box area inside bubbles-top.png
	// Initial middle height, will change later based on contents.
	var middleheight = 20;
	// This is the height (in pixels) of the "bubbles-bottom.png" image
	var bottomheight = 28;

	var cornertipx = pos.x + pos.w - 5;
	var cornertipy = pos.y + pos.h - 5;

	var xmargin = 30;

	var divs = {};

	// Div containing bubbles-top.png
	divs.arrowcontainertop = createDiv(node, cornertipx, cornertipy, bigarrowwidth, topheight, 1.0, "");
	divs.arrowcontainertop.style.backgroundImage = "url(chrome://coscripter/skin/images/bubbles-top.png)";
	divs.arrowcontainertop.style.width=bigarrowwidth+"px";
	divs.arrowcontainertop.style.height=topheight + "px";
	divs.arrowcontainertop.innerHTML = "&nbsp;";

	// Div containing bubbles-middle.png and the slop
	divs.arrowcontainermiddle = createDiv(node, cornertipx, cornertipy + topheight, bigarrowwidth, middleheight, 1.0, "");
	divs.arrowcontainermiddle.style.backgroundImage = "url(chrome://coscripter/skin/images/bubbles-middle.png)";
	divs.arrowcontainermiddle.style.width=bigarrowwidth+"px";
	divs.arrowcontainermiddle.style.height=middleheight+"px";
	divs.arrowcontainermiddle.innerHTML = "&nbsp;";

	// Div containing bubbles-bottom.png
	divs.arrowcontainerbottom = createDiv(node, cornertipx, cornertipy + topheight + middleheight, bigarrowwidth, bottomheight, 1.0, "");
	divs.arrowcontainerbottom.style.backgroundImage = "url(chrome://coscripter/skin/images/bubbles-bottom.png)";
	divs.arrowcontainerbottom.style.width=bigarrowwidth+"px";
	divs.arrowcontainerbottom.style.height=bottomheight+"px";
	divs.arrowcontainerbottom.innerHTML = "&nbsp;";

	// Div inside the arrowcontainermiddle which will contain slop
	divs.slopholder = createDiv(node, cornertipx+arrowboxleft, cornertipy + topheight, bigarrowwidth-arrowboxleft-7, 195, 1.0, "");
	// TL: don't know why these increase the width of the div
	/*
	divs.slopholder.style.borderLeft = "50px";
	divs.slopholder.style.borderRight = "50px";
	divs.slopholder.style.paddingLeft = "50px";
	divs.slopholder.style.paddingRight = "50px";
	*/

	// Div containing the buttons along the bottom of the bubble
	divs.buttonholder = createDiv(node, (cornertipx + xmargin), cornertipy + topheight + 200, bigarrowwidth - (xmargin*2), 50, 1.0, "");

	// Set the zIndex to bring them more forward (might not work if other
	// things on the page have higher zIndices)
	for(div in divs) {
		divs[div].style.zIndex = (parseInt(divs[div].style.zIndex) + 5);
	}

	// Reposition the DIVs to appear before/after the target node.
	// Necessary to provide correct ordering for screen reader users.
	var nodeParent = node.parentNode;

	// Reposition/replace/restyle the top div.
	nodeParent.insertBefore(divs.slopholder.parentNode.removeChild(divs.slopholder), node);
	//divs.slopholder.style.MozBorderRadius = "15px 15px 0 0";

	// Reposition/replace/restyle the bottom div.
	//divs.bottom.style.MozBorderRadius = "0 0 15px 15px";
	if(node.nextSibling) {
		nodeParent.insertBefore(divs.buttonholder.parentNode.removeChild(divs.buttonholder), node.nextSibling);
	} else {
		nodeParent.appendChild(divs.buttonholder.parentNode.removeChild(divs.buttonholder));
	}

	divs.slopholder.style.zIndex = (parseInt(divs[div].style.zIndex) + 10);
	divs.buttonholder.style.zIndex = (parseInt(divs[div].style.zIndex) + 10);

	return divs;
}

function makeBigArrowInfoHighlight(doc) {
	// Hardcoded dimensions of all the info-left, info-right.png images
	var biginfoheight = 77;
	var leftwidth = 37;
	var rightwidth = 32;
	// Initial middle width, will change later based on contents.
	var middlewidth = 20;

	var divs = {};

	divs.infocontainerleft = createDiv(doc, 0, 0, leftwidth, biginfoheight, 1.0, "");
	divs.infocontainerleft.style.backgroundImage = "url(chrome://coscripter/skin/images/info-left.png)";
	divs.infocontainerleft.style.width=leftwidth+"px";
	divs.infocontainerleft.style.height=biginfoheight + "px";
	divs.infocontainerleft.innerHTML = "&nbsp;";

	divs.infocontainermiddle = createDiv(doc, leftwidth, 0, middlewidth, biginfoheight, 1.0, "");
	divs.infocontainermiddle.style.backgroundImage = "url(chrome://coscripter/skin/images/info-middle.png)";
	divs.infocontainermiddle.style.width=middlewidth+"px";
	divs.infocontainermiddle.style.height=biginfoheight+"px";
	divs.infocontainermiddle.innerHTML = "&nbsp;";

	divs.infocontainerright = createDiv(doc, leftwidth + middlewidth, 0, rightwidth, biginfoheight, 1.0, "");
	divs.infocontainerright.style.backgroundImage = "url(chrome://coscripter/skin/images/info-right.png)";
	divs.infocontainerright.style.width=rightwidth+"px";
	divs.infocontainerright.style.height=biginfoheight+"px";
	divs.infocontainerright.innerHTML = "&nbsp;";

	divs.slopholder = createDiv(doc, leftwidth, 0, 200, Math.floor(biginfoheight / 2), 1.0, "");
	divs.buttonholder = createDiv(doc, leftwidth, Math.floor(biginfoheight / 2), 200, Math.floor(biginfoheight / 2), 1.0, "");

	for(div in divs) {
		divs[div].style.zIndex = (parseInt(divs[div].style.zIndex) + 5);
	}

	// Reposition/replace/restyle the top div.
	if(doc.body.firstChild != null) {
		doc.body.insertBefore(divs.buttonholder.parentNode.removeChild(divs.buttonholder), doc.body.firstChild);
		doc.body.insertBefore(divs.slopholder.parentNode.removeChild(divs.slopholder), divs.buttonhodler);
	} else {
		doc.body.appendChild(divs.slopholder);
		doc.body.appendChild(divs.buttonholder);
	}

	divs.slopholder.style.zIndex = (parseInt(divs[div].style.zIndex) + 10);
	divs.buttonholder.style.zIndex = (parseInt(divs[div].style.zIndex) + 10);

	return divs;
}


function makeBigHighlight(node, color, slopw, sloph) {
    if (node.tagName == "OPTION") {
        node = node.parentNode
    }

    if (!color) {
        color = "red"
    }

    var pos = getNodePosition(node)

	var dt = sloph + 5; // top margin of preview pane
	var db = 50; // bottom margin
	var dl = 100; //Math.ceil((pos.w + )/2); // left margin
	var dr = 100; // right margin
	var opacity = 0.8;

	var divs = {};

	divs.top = createDiv(node, pos.x - dl, pos.y - dt, pos.w + dl + dr, dt, opacity, color);
	divs.bottom = createDiv(node, pos.x - dl, pos.y + pos.h, pos.w + dl + dr, db, opacity, color);

	divs.left = createDiv(node, pos.x - dl, pos.y, dl, pos.h, opacity, color);
	divs.right = createDiv(node, pos.x + pos.w, pos.y, dr+2, pos.h, opacity, color);

	for(div in divs) {
		divs[div].style.zIndex = (parseInt(divs[div].style.zIndex) - 1);
	}

	// Reposition the DIVs to appear before/after the target node.
	// Necessary to provide correct ordering for screen reader users.
	var nodeParent = node.parentNode;

	// Reposition/replace/restyle the top div.
	var topdiv = divs.top;
	nodeParent.insertBefore(divs.top.parentNode.removeChild(divs.top), node);
	divs.top.style.MozBorderRadius = "15px 15px 0 0";

	// Reposition/replace/restyle the bottom div.
	divs.bottom.style.MozBorderRadius = "0 0 15px 15px";
	if(node.nextSibling) {
		nodeParent.insertBefore(divs.bottom.parentNode.removeChild(divs.bottom), node.nextSibling);
	} else {
		nodeParent.appendChild(divs.bottom.parentNode.removeChild(divs.bottom));
	}

	// Reposition/replace the left div.
	nodeParent.insertBefore(divs.left.parentNode.removeChild(divs.left), node);

	// Reposition/replace the right div.
	nodeParent.insertBefore(divs.right.parentNode.removeChild(divs.right), divs.bottom);

	return divs;
}

// End of highlight-oriented functions
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
// Timing: wait for a page to load, then do something else

// Creates a neat green transparent animation thing over the *item*,
// and when it's done working its magic, it calls *doThis*,
// so let's say you want to show the user that you are pressing a given button,
// and when you're done showing them that, you want to say "I'm done!",
// you could do:
//      var button = document.getElementById("cool-button")
//      highlightThenDo(button, function() {alert("I'm done!")})
function highlightThenDo(item, doThis, color) {
    if (item.tagName == "OPTION") {item = item.parentNode}
    if (color == null) color = "green";
	var window = item.ownerDocument.defaultView
	var scrolled = ensureVisible(item)
    var pos = getNodePosition(item)
    var div
    var div2
    var o = 1
    
    try {
        div = createDiv(item, pos.x, pos.y, pos.w, pos.h, 1, color)
        div2 = createDiv(item, pos.x, pos.y, pos.w, pos.h, 0.5, color)
    } catch (e) {}
    
    window.setTimeout(
		function() {
			for (var i = 1; i <= 10; i++) {
				var inc = 3
				window.setTimeout(
					function () {
						pos.x -= inc
						pos.y -= inc
						pos.w -= -2 * inc
						pos.h -= -2 * inc
						o /= 1.45
						try {
							setDivStyle(div, pos.x, pos.y, pos.w, pos.h, o, color)
						} catch (e) {}
					}, 
					(i * 25)  
				) // end of first inner window.setTimeout
			} // end of For loop, displaying expanding green outline
			window.setTimeout(
				function () {
					try {
						div.parentNode.removeChild(div)
						div2.parentNode.removeChild(div2)
					} catch (e) {}
					if (doThis != undefined) {
						doThis()
					}
				}, 
				((10 + 2) * 25)
			) //end of second inner window.setTimeout
		},   //end of first argument to outermost window.setTimeout
		(scrolled ? 500 : 0)  // second argument to outermost window.setTimeout
	) //end of outermost window.setTimeout
}


//	betterThenDoThis
//Call this to make sure that thenDoThis won't get executed until the window finishes loading.
//If the window isn't in fact loading, it will also work fine.
// should be called: if_there_is_a_page_loading_then_let_it_finish_before_doing_this
function betterThenDoThis(window, thenDoThis) {
	// TL: the test sidebar V2 needs to be able to specify that there is no "thenDoThis" function, 
	// i.e. that we shouldn't do anything after a command is executed.
	if (thenDoThis == null) return;

	// The window passed in is the Chrome window.
	//ToDo: also need to wait for XMLHttpRequests to complete. 
	//debug("in betterThenDoThis")
	//debug("in betterThenDoThis t=" + (new Date() - timer )); 
	try{
		window.setTimeout(function() {
			try{
					var browser = getBrowser(window)	//Doesn't Work when window is in the sidebar
					if (!browser) {
						//debug('betterThenDoThis: no browser')
						thenDoThis()
					} else {
						var webProgress = browser.webProgress
						//debug("betterThenDoThis setTimeout and progress is " + webProgress.isLoadingDocument)
						if (webProgress.isLoadingDocument) {
							//debug("betterThenDoThis waiting for page to load t=" + (new Date() - timer ))
							//debug('betterThenDoThis: about to wait for page to load')
							//dump('bTDT: doc is loading, calling wFPTL\n');
							//dump('bTDT: browser url: ' + browser.currentURI.spec + '\n');
							waitForPageToLoad(browser, thenDoThis)
							//debug('betterThenDoThis: after waitForPageToLoad')
						} else {
							//debug("betterThenDoThis does NOT need to wait for page to load t=" + (new Date() - timer ))
							//dump('bTDT: page is not loading, calling tDT\n');
							thenDoThis()
						}
					}
			}catch(e){
				debug('exception inside window.timeout inside betterThenDoThis: ' +e.toSource() );
			}
			//debug("betterThenDoThis: done inside window.setTimeout's function")
			}, 0)
		//debug("betterThenDoThis: after window.setTimeout")
	}catch(e){
		debug('exception in betterThenDoThis: ' +e );
	}
}

// TL: use a global variable to keep track of the current "onload" handler
// for the document in the main browser window.  This is used to cancel the
// onload handler when the user clicks the Stop button in the GUI.
var currentThenDoThis = null;

// adds a load handler which will trigger when the given browser finishes loading,
// and it will call *thenDoThis* (and clean up the handler so it doesn't fire in the future ;)
function waitForPageToLoad(browser, thenDoThis) {
    // TL 8/22/07: not sure removing the old one is necessary, but it might
    // prevent multiple handlers from being registered and causing odd behavior.
    if (null != currentThenDoThis) {
		//dump('wFPTL: removing old page load handler\n');
		removePageLoadHandler(browser);
    }

//  CD 4/1/08 what is this supposed to do?
//	var chrome = getWindowRoot(browser.ownerDocument.defaultView);
//	chrome.addEventListener("load", function(e){return true}, true)

	var pageLoadObserver =  new OldPageLoadObserver(thenDoThis,browser);

	currentThenDoThis = pageLoadObserver;
		
    // TL: here we want to add a listener on failure to detect when the
    // page load could not complete for some reason
    // chrome.addEventListener("load", currentThenDoThis, true);
}

pageLoadObserverCounter = 0;

function PageLoadObserver(thenDoThis){
	this.id = pageLoadObserverCounter ++;
	this.thenDoThis = thenDoThis ;
	this.register() ;
	return this ;
} 

// CD 12/12/07:
// this is a new pageload observer that uses the notification from Mozilla when a page stopped
// loading completely. This lead to timing problems in run more and is hence disabled for now
// it may be necessary to debug this further if the old onload handler turns out to 
// cause problems with pages that have multiple frames.
PageLoadObserver.prototype = {
	observe : function(window){
		this.thenDoThis();
		this.unregister();
		// debug("Page loaded. waitForPageToLoad is no longer waiting id:"+this.id)
	},
	register : function(){
		// debug('registering pageLoadObserverCounter id:' + this.id);
		var observerService = Components.classes["@mozilla.org/observer-service;1"].
			getService(Components.interfaces["nsIObserverService"]);
		observerService.addObserver(this, "EndDocumentLoad", false);
	},
	unregister : function(){
		debug('unregistering pageLoadObserverCounter id:' + this.id);
	 	var observerService = Components.classes["@mozilla.org/observer-service;1"].
			getService(Components.interfaces["nsIObserverService"]);
		observerService.removeObserver(this,"EndDocumentLoad");
	}	
}

// this is the old pageload observer that uses an onload handler on the current frame
function OldPageLoadObserver(thenDoThis,browser){
	this.thenDoThis = thenDoThis;
	this.browser = browser ;
	this.chrome = getWindowRoot(browser.ownerDocument.defaultView);
	this.register();
	return this ;
}

OldPageLoadObserver.prototype={
	register : function(){
		var thisObserver = this ;
		this.callback = function(e){
			thisObserver.onLoad(e,thisObserver);
		}
		this.chrome.gBrowser.addEventListener("load", this.callback, true);
	},
	unregister : function(){
		this.chrome.gBrowser.removeEventListener("load", this.callback, true)
	},
    onLoad : function(e,thisObserver){
		if (!thisObserver.browser || !thisObserver.browser.contentDocument) return;
        var uri = thisObserver.browser.contentDocument.documentURI,
            loc = thisObserver.browser.contentWindow.location;

        if (e.originalTarget == thisObserver.browser.contentDocument) {
            thisObserver.unregister();
            currentThenDoThis = null;
            thisObserver.thenDoThis()
        }
        else if (/^about:neterror\?e=nssBadCert/.test(uri)
                     || /^about:certerror/.test(uri)) {

            // unregister to avoid being called again because of the reload made
            // by addSSLCertException
            thisObserver.unregister();
            addSSLCertException(loc, thisObserver.chrome.gBrowser, function () {
                // now that we registered the exception, try again to see if the
                // page loaded
                if (e.originalTarget == thisObserver.browser.contentDocument) {
                    currentThenDoThis = null;
                    thisObserver.thenDoThis();
                }
                else {
                    // if the page isn't the one we are expecting re-register
                    // the handler
                    thisObserver.chrome.gBrowser.addEventListener("load", function (e) {
                        thisObserver.onLoadSimple(e, thisObserver);
                    }, true);
                }
            });

        }
    },

    // to avoid re registering the handler multiple times after we added the
    // SSL exception this handler is registered the second time
    onLoadSimple: function (e, thisObserver) {
        if (e.originalTarget == thisObserver.browser.contentDocument) {
            thisObserver.unregister();
            currentThenDoThis = null;
            thisObserver.thenDoThis();
        }
    }
}

// this will get called by the onStop callback to cancel outstanding handlers
function removePageLoadHandler(browser) {
	if (currentThenDoThis != null) {
		currentThenDoThis.unregister();
		currentThenDoThis = null;
	}
}


// End timing-related functions
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
////////////////////////////////////
///////////// Execution ////////////
////////////////////////////////////
// These are the routines that perform commands that type and click in the browser window

///////////////////////////
//	Select
////////////////////////////
// Clicks buttons and links
// operates on checkboxes, radio buttons, and list items
// Used by "select" and "turn" commands
// make *selectP* true if you want to select (or check) the given *item*,
// and make *selectP* false if you want to deselect (or uncheck) it,
//
// NOTE: this will highlight what you're doing,
// and it will call *thenDoThis* when it has finished
function select(item, thenDoThis, specialKey, selectP, options) {
    var window = getChromeWindowForNode(item);
    if (selectP == undefined) {selectP = true;}
	
	if (item.tagName.toUpperCase() == "OPTION") {
		if (item.parentNode.getAttribute("multiple") == "multiple") {
			if (specialKey == "control") {
				selectListItem(item, thenDoThis, selectP, true, false, options)
			}
			else if (specialKey == "shift") {
				selectListItem(item, thenDoThis, selectP, false, true, options)
			} else {
				selectListItem(item, thenDoThis, selectP, false, false, options)
			}
		}			
		else selectListItem(item, thenDoThis, selectP, false, false, options);
		return;
	} 
	
	if (item.tagName.toUpperCase() == "INPUT") {
		if (item.title && (item.title.indexOf("selected checkbox") != -1 || item.title.indexOf("selected radio") != -1)) {	// kludge for RAM checkboxes
			var currentlySelectedP = !(item.title.indexOf("unselected") != -1)
			if (!(currentlySelectedP ^ selectP)) {	// not XOR means that they match
				betterThenDoThis(window, thenDoThis);
				return;
			}
		}
		else if(!(item.checked ^ selectP)) {	// not XOR means that they match
			betterThenDoThis(window, thenDoThis);
			return;
		}
	}

	if (item.tagName.toUpperCase() == "IMG") {	// kludge for Cobra clickableIcon
		var imageName = item.getAttribute("src")
		var result = imageName.match(/.*\b(\w+)_(y|yh|n|nh)\..../)	// e.g. etl/imgs/  modelgen  _  n  .png
		if (result) {
			var label = result[1]
			var iconState = result[2]
			var isOnP = (iconState == "y" || iconState == "yh")
			if(isOnP == selectP) {	// already in the correct state, so do nothing
				betterThenDoThis(window, thenDoThis);
				return;
			}
		}
	}

    var color = null;
    if (options != null && options.color != null) color = options.color;
	var mouseDownEvent = constructMouseDownEvent(item);
	var mouseUpEvent = constructMouseUpEvent(item);
	var clickEvent = constructClickEvent(item);
	highlightThenDo(item, function() {
		// TL: in some cases, the dispatchEvent call never returns, so we
		// never call thenDoThis() to resume execution.  This seems to
		// happen when there's an onclick handler using the YUI library.
		// Not sure how to handle this.  If you put the betterThenDoThis
		// call before the dispatchEvent, it works, but that seems like a
		// hack.
		try {
			item.dispatchEvent(mouseDownEvent);
			item.dispatchEvent(mouseUpEvent);
			item.dispatchEvent(clickEvent);
		} catch (e) {
			d('Error dispatching event: ' + e + '\n');
		}
		betterThenDoThis(window, thenDoThis);
	}, color)
}	// end of select command

//list items are executed indirectly, since the list isn't visible to click on it
//selectP specifies whether we want to select or deselect the item, since selectListItem is used for both
function selectListItem(item, thenDoThis, selectP, controlP, shiftP, options) {
    var window = getChromeWindowForNode(item)
	var parentItem = item.parentNode
	var prevSelectedIndex = parentItem.selectedIndex
	var onChangeP = parentItem.hasAttribute("onchange") 
	var onClickP = parentItem.hasAttribute("onclick") 
    var color = null;
    if (options != null && options.color != null) color = options.color;
    
	highlightThenDo(item, function() {
		if (!shiftP){
			var change = (item.selected != selectP)
			item.selected = selectP	//select listItem
			if (parentItem.getAttribute("multiple") == "multiple"){	// for multi listbox, unselect the previous selection unless this is a control-select
				// Note: there is a FFox bug so multi listboxes don't maintain parentItem.selectedOptions, so we're erring and only deselecting a single item: https://bugzilla.mozilla.org/show_bug.cgi?id=596681
				if(!controlP) parentItem.childNodes[prevSelectedIndex].selected = false
				if (change && !controlP) parentItem.selectedIndex = item.index	// Not sure why, but this seems to deselect *all* selected items
			}
		} else {	// shift-select
			prevSelectedIndex = parentItem.selectedIndex
			var itemIndex = item.index
			var firstIndex = (prevSelectedIndex < itemIndex) ? prevSelectedIndex : itemIndex
			var lastIndex =  (prevSelectedIndex < itemIndex) ? itemIndex : prevSelectedIndex
			for (var i=firstIndex; i<=lastIndex; i++ ) {
				parentItem.childNodes[i].selected = true
			}
		}
		// run any onChange or onClick methods on the parent
		if (change) {
			try {
				// generating the correct event will cause any onchange attribute methods to be called				
				var changeEvent = constructChangeEvent(parentItem)
				parentItem.dispatchEvent(changeEvent);
				
			} catch (er) {
				if (Components.reportError) {Components.reportError(er)}
			}
		}
		if (onClickP) {
			//execute the onclick handler
			window.setTimeout(
				function () {
					try {
						parentItem.onclick()
					} catch (e) {debug("parentItem.onclick failed")}
				}, 
				0
			) //end of window.setTimeout
		}
		
		betterThenDoThis(window, thenDoThis)
	}, color)
}


// find the corresponding select node given one of its 'option' children
function getSelectNodeForItemNode(node){
	p = node;
	for(p=node;p!=p.parentNode;p=p.parentNode){
		if(p.nodeName == 'SELECT'){
			return p ;
		}
	}
}

// operates on checkboxes, radio buttons, and list items
// NOTE: this will highlight what you're doing,
// and it will call *thenDoThis* when it has finished
function deselect(item, thenDoThis) {
    select(item, thenDoThis, false)
}

// operates on checkboxes, radio buttons, and list items,
// and tells you in true/false terms whether the *item* is selected (or checked)
function getSelected(item) {
    if (item.tagName == "OPTION") {
        return item.selected
    } else {
        return item.checked
    }
}

// operates on checkboxes, radio buttons, and list items,
// and flips the selected/checked status of the *item*
// NOTE: this will highlight what you're doing,
// and it will call *thenDoThis* when it has finished
function toggle(item, thenDoThis) {
    turn(item, !getSelected(item), thenDoThis)
}

// very similar to select, in fact it expands out to select,
// but it's here as a legacy function
function turn(item, turnOn, thenDoThis) {
    if (turnOn) {
        select(item, thenDoThis)
    } else {
        deselect(item, thenDoThis)
    }
}

// Only Expand if the item is currently collapsed
// used by dijits
function expandOrCollapse(item, expandP, thenDoThis) {
	var window = getChromeWindowForNode(item)
	if (item.hasAttribute("coscripterExpandedP")) {
		var alreadyExpandedP = (item.getAttribute("coscripterExpandedP") == "true")
		if(item.getAttribute("coscripterExpandedP") && expandP == alreadyExpandedP) {
			betterThenDoThis(window, thenDoThis);
			return;
		}
	}
    if (expandP) {
        select(item, thenDoThis)
    } else {
        deselect(item, thenDoThis)
    }
}


///////////////////////////
//	Click
////////////////////////////
// Clicks buttons and links
//
// NOTE: this will highlight what you're doing, and it will call *thenDoThis* when it has finished 
//(which will include loading the new webpage, if that happens as a result of clicking this link/button)
//
var timer = 0;

function click(item, thenDoThis, ctrlP, shiftP, options) {
	//debug("about to click")
    var chromeWindow = getChromeWindowForNode(item)
    var tabbrowser = getWindowRoot(chromeWindow).document.getElementById("content")
	
    var color = null;
    if (options != null && options.color != null) color = options.color;
	
	if (xulNodeP(item) && dialogButtonP(item)) {
		dialogButtonClick(item, thenDoThis, ctrlP, options, color)
		return
	}		
	if (xulNodeP(item) && menuItemP(item)) {
		menuItemClick(item, thenDoThis, ctrlP, options, color)
		return
	}		
	if (xulNodeP(item) && prefPaneP(item)) {
		prefPaneClick(item, thenDoThis, ctrlP, options, color)
		return
	}	
	
	var clickLoc = null;
	if (options != null && options.clickLoc) clickLoc = options.clickLoc	//used by xPath commands

	/*
	// For Maximo, click the topmost element at the location of item, since sometimes it overlays the entire window with a div. (AC)
	var doc = item.ownerDocument
	//if (!item.offsetParent) debug("click: there is no offsetParent")
	//else debug("click: offset Parent Top and left are " + item.offsetParent.nodeName + ", " + item.offsetTop + ", " + item.offsetLeft)
	var itemRect = item.getBoundingClientRect()
	var itemX = (itemRect.left + itemRect.right) * 0.5
	var itemY = (itemRect.bottom + itemRect.top) * 0.5
	try {
		var topItem = doc.elementFromPoint(itemX,itemY)
	}catch(e){ 
		debug("click: error in doc.elementFromPoint: " + e.toString())
		topItem = null
	}
	if (!topItem) topItem = item
	
	var topItemRect = topItem.getBoundingClientRect()
	var clickX = (topItemRect.left + topItemRect.right) * 0.5
	var clickY = (topItemRect.bottom + topItemRect.top) * 0.5
	clickLoc = { x	: clickX, y	: clickY }
	if (item.nodeName.toUpperCase() == "AREA") {	// use the original item for imagemaps
		topItem = item
		clickLoc = null
	}
	*/
	
	var mouseOverEvent = constructMouseOverEvent(item, ctrlP, shiftP, clickLoc);
	var mouseDownEvent = constructMouseDownEvent(item, ctrlP, shiftP, clickLoc);
	var mouseUpEvent = constructMouseUpEvent(item, ctrlP, shiftP, clickLoc);
	var clickEvent = constructClickEvent(item, ctrlP, shiftP, clickLoc)
	//debug("click is executing on item with id = " + item.getAttribute("id"))
	//browser.addProgressListener(frameLoadListener, Components.interfaces.nsIWebProgress.NOTIFY_STATE_ALL);
    highlightThenDo(item, function(){}, color)
	item.dispatchEvent(mouseOverEvent);
	item.dispatchEvent(mouseDownEvent);
	item.dispatchEvent(mouseUpEvent);
	item.dispatchEvent(clickEvent);
	
	if (tabbrowser) betterThenDoThis(chromeWindow, thenDoThis)
	else thenDoThis()
}

// Is this an OK or Cancel button in a xul Dialog
function dialogButtonP(item){
	var doc = getXulDocument(item)
	if (!doc) return false
	
	var okButton = null
	if (doc.getButton) okButton = doc.getButton("accept")
	if (!okButton && doc.documentElement.getButton) okButton = doc.documentElement.getButton("accept")
	var cancelButton = null
	if (doc.getButton) cancelButton = doc.getButton("cancel")
	if (!cancelButton && doc.documentElement.getButton) cancelButton = doc.documentElement.getButton("cancel")
	if (item == okButton || item == cancelButton) return true
	return false
}

function dialogButtonClick(item, thenDoThis, ctrlP, options, color) {
	//debug("doing a dialog button click")
	//highlightThenDo(item, function() {}, color)
	var doc = getXulDocument(item)
	
	// Click on OK and Cancel buttons in a xul Dialog
	var okButton = null
	if (doc.getButton) okButton = doc.getButton("accept")
	if (!okButton && doc.documentElement.getButton) okButton = doc.documentElement.getButton("accept")
	var cancelButton = null
	if (doc.getButton) cancelButton = doc.getButton("cancel")
	if (!cancelButton && doc.documentElement.getButton) cancelButton = doc.documentElement.getButton("cancel")
	if (item == okButton || item == cancelButton) {
		item.click()
		//debug("clicked")
	}

	var chromeWindow = doc.defaultView
    //var chromeWindow = getChromeWindowForNode(item)
	//var browser = getBrowser(chromeWindow)
    var tabbrowser = getWindowRoot(chromeWindow).document.getElementById("content")
	if (tabbrowser) betterThenDoThis(chromeWindow, thenDoThis)
	else thenDoThis()
}

// to handle the Preferences button in the Add-ons window
function menuItemP(item){
	if (item.localName == "menuitem") return true
	return false
}

function menuItemClick(item, thenDoThis, ctrlP, options, color) {
	//debug("doing a menuItem click")
	try {
		var commandName = item.command
		if(!commandName) return;
		var doc = item.ownerDocument
		var commandNode = doc.getElementById(commandName)
		var chromeWindow = doc.defaultView
	    var tabbrowser = getWindowRoot(chromeWindow).document.getElementById("content")
		
		commandNode.doCommand()
	
		if (tabbrowser) betterThenDoThis(chromeWindow, thenDoThis)
		else thenDoThis()
	}catch(e){ debug("menuItemClick: failed with error: " + e.toString())}
}


// to handle the Preferences button in the Add-ons window
function prefPaneP(item){
	if (item.localName == "prefpane") return true
	return false
}

function prefPaneClick(item, thenDoThis, ctrlP, options, color) {
	//debug("doing a menuItem click")
	try {
		var doc = item.ownerDocument
		var chromeWindow = doc.defaultView
	    var tabbrowser = getWindowRoot(chromeWindow).document.getElementById("content")
		
		var prefWindow = item.parentNode
		prefWindow.showPane(item)
	
		if (tabbrowser) betterThenDoThis(chromeWindow, thenDoThis)
		else thenDoThis()
	}catch(e){ debug("prefPaneClick: failed with error: " + e.toString())}
}

function mouseover(item, thenDoThis, ctrlP, options) {
	debug("about to mouseover")
    var chromeWindow = getChromeWindowForNode(item)
    var tabbrowser = getWindowRoot(chromeWindow).document.getElementById("content")
    var color = null;
    if (options != null && options.color != null) color = options.color;
	
	if (xulNodeP(item) && dialogButtonP(item)) {
		debug("mouseover not handled for dialog buttons")
		return
	}		
	if (xulNodeP(item) && menuItemP(item)) {
		debug("mouseover not handled for menu items")
		return
	}		
	if (xulNodeP(item) && prefPaneP(item)) {
		debug("mouseover not handled for prefPanes")
		return
	}	
	
	//var onmouseoverP = item.hasAttribute("onmouseOver")
	var clickLoc = null;
	if (options != null && options.clickLoc) clickLoc = options.clickLoc	//used by xPath commands

	/*
	// mouseOver the topmost element at the location of item.  
	// Needed for Maximo which overlays the entire window with a div. (AC)
	var doc = item.ownerDocument
	var itemRect = item.getBoundingClientRect()
	var itemX = (itemRect.left + itemRect.right) * 0.5
	var itemY = (itemRect.bottom + itemRect.top) * 0.5
	var topItem = doc.elementFromPoint(itemX,itemY)
	if (!topItem) topItem = item
	var topItemRect = topItem.getBoundingClientRect()
	clickLoc = { x	:	(topItemRect.left + topItemRect.right) * 0.5, y	:	(topItemRect.bottom + topItemRect.top) * 0.5 }
	if (item.nodeName.toUpperCase() == "AREA") {	// use the original item for imagemaps
		topItem = item
		clickLoc = null
	}
	*/
	
	var mouseOverEvent = constructMouseOverEvent(item, ctrlP, clickLoc);
	debug("mouseover is executing on item with id = " + item.getAttribute("id"))
    highlightThenDo(item, function(){}, color)
	item.dispatchEvent(mouseOverEvent);
	
	if (tabbrowser) betterThenDoThis(chromeWindow, thenDoThis)
	else thenDoThis()
}



function macPlatformP(contentWindow) {
	if (contentWindow.navigator && contentWindow.navigator.platform) {
		var platform =  contentWindow.navigator.platform
		return (platform.indexOf("Mac") != -1)
	}
	return false
}

//		constructMouseEvent
// synthesize a mouse event on this element
function constructMouseEvent(type, element, ctrlP, shiftP, clickLoc) {
	var contentDocument = element.ownerDocument  
	var contentWindow = contentDocument.defaultView  
	var nodePosition = getNodePosition(element) 
	var clickLocH = nodePosition.x + Math.floor(nodePosition.w / 2)
	var clickLocV = nodePosition.y + Math.floor(nodePosition.h / 2)
	if (clickLoc != null) {
		clickLocH = nodePosition.x + parseInt(clickLoc.x)
		clickLocV = nodePosition.y + parseInt(clickLoc.y)
	}
	var macP = macPlatformP(contentWindow)
	var theEvent = contentDocument.createEvent("MouseEvents")	
	
	theEvent.initMouseEvent(type, true, true, contentWindow, 1,
	    	(contentWindow.screenX + clickLocH), (contentWindow.screenY + clickLocV),
		clickLocH, clickLocV, // screen x, y, client x, y  
		ctrlP && !macP, false, shiftP, ctrlP && macP, 0, null)  // ctl,alt,shift,meta,0=left-button,	
		
	return theEvent
}

// synthesize a click event on this element
function constructClickEvent(element, ctrlP, shiftP, clickLoc) {
	return constructMouseEvent("click", element, ctrlP, shiftP, clickLoc);
}

// synthesize a MouseOver event on this element
function constructMouseOverEvent(element, ctrlP, shiftP, clickLoc) {
	return constructMouseEvent("mouseover", element, ctrlP, shiftP, clickLoc);
}

// synthesize a MouseDown event on this element
function constructMouseDownEvent(element, ctrlP, shiftP, clickLoc) {
	return constructMouseEvent("mousedown", element, ctrlP, shiftP, clickLoc);
}

// synthesize a MouseUp event on this element
function constructMouseUpEvent(element, ctrlP, shiftP, clickLoc) {
	return constructMouseEvent("mouseup", element, ctrlP, shiftP, clickLoc);
}


///////////////////////////
//	Enter
////////////////////////////

// enters *string* into the given *textbox*,
// and shows you a nice green highlighting effect,
// and calls *thenDoThis* when that highlight is finished
function enter(string, textbox, thenDoThis, options) {
    var chromeWindow = getChromeWindowForNode(textbox)
    var color = null;
    if (options != null && options.color != null) color = options.color;
		
    var focusEvent = textbox.ownerDocument.createEvent('HTMLEvents');
    var blurEvent = textbox.ownerDocument.createEvent('HTMLEvents');
    focusEvent.initEvent('focus', true, false);
    blurEvent.initEvent('blur', true, false);
	var changeEvent = constructChangeEvent(textbox)

	//Kludge to handle typing the "Enter" key
	if (string == "\n") {
		typeEnterKey(textbox, thenDoThis)
		return;
	}
	
	var mouseDownEvent = constructMouseEvent("mousedown", textbox);
	
    highlightThenDo(textbox, function() {
	    textbox.dispatchEvent(focusEvent);
		textbox.dispatchEvent(mouseDownEvent);
		var dojotype = textbox.getAttribute("dojotype")
		if (dojotype && dojotype.indexOf("InlineEditBox") != -1) textbox.textContent = string
		else if (textbox.nodeName == "BODY") textbox.textContent = string	// dojo rich text editor
        else textbox.value = string
		//send an onChange event since we didn't change focus at all
		textbox.dispatchEvent(changeEvent)
	    textbox.dispatchEvent(blurEvent);
        betterThenDoThis(chromeWindow, thenDoThis)
    }, color)
}



function constructChangeEvent(element) {
	var contentDocument = element.ownerDocument  
	var theEvent = contentDocument.createEvent("HTMLEvents");
	//contentDocument.initEvent("change", true, true)
	theEvent.initEvent("change", true, false);	// bubbles; cancelable
	return theEvent
}

// TODO Merging between trunk and vegemite seems to have introduced
// multiple key-event handling code. Needs to be cleaned up.

function constructEvent(eventType, element) {
	var ownerDocument = element.ownerDocument  
	var theEvent = ownerDocument.createEvent("KeyboardEvent")
	//contentDocument.initEvent("change", true, true)
	//theEvent.initEvent("change", true, false)
	theEvent.initKeyEvent (eventType, 
						true, true, null, 					// bubbles, cancelable, viewArg
                        false, false, false, false,			// ctrlKeyArg, altKeyArg, shiftKeyArg, metaKeyArg,
                        keyCode, charCode)					// keyCodeArg, charCodeArg
	//isEnter = true
	return theEvent
}

function typeEnterKey(textbox, thenDoThis) {
	var keyCode = 13
	var charCode = 0
	var keyDownEvent = createAndInitKeyboardEvent("keydown", textbox, keyCode, charCode, false)
	var keyPressEvent = createAndInitKeyboardEvent("keypress", textbox, keyCode, charCode, false)
	var keyUpEvent = createAndInitKeyboardEvent("keyup", textbox, keyCode, charCode, false)
	var inputEvent = constructInputEvent(textbox)
	textbox.dispatchEvent(keyDownEvent)
	textbox.dispatchEvent(keyPressEvent)
	textbox.dispatchEvent(inputEvent)
	textbox.dispatchEvent(keyUpEvent)
	
	var chromeWindow = getChromeWindowForNode(textbox)
	betterThenDoThis(chromeWindow, thenDoThis)
}

// NOT USED (AC 15Mar11)
// appends *string* to the text in the given *textbox*,
// and shows you a nice green highlighting effect,
// and calls *thenDoThis* when that highlight is finished
function appendText(string, textbox, thenDoThis, options) {
    var color = null;
    if (options != null && options.color != null) color = options.color;
    var chromeWindow = getChromeWindowForNode(textbox)
    textbox.scrollTop = textbox.scrollHeight
    highlightThenDo(textbox, function() {
        unfancy_appendText(string, textbox)
        textbox.scrollTop = textbox.scrollHeight
        betterThenDoThis(chromeWindow, thenDoThis)
    }, color)
}

// appends *string* to the text in the given *textbox* without showing you a fancy green highlight effect
function unfancy_appendText(string, textbox) {
	var s = ""
	var dojotype = textbox.getAttribute("dojotype")
	if (dojotype && dojotype.indexOf("InlineEditBox") != -1) s = textbox.textContent
	else if (textbox.nodeName == "BODY") s = textbox.textContent	// dojo rich text editor
    else s = textbox.value

    if (!s.match(/\n$/)) {
        s += "\n"
    }
    s += string

	if (dojotype && dojotype.indexOf("InlineEditBox") != -1) textbox.textContent = s
	else if (textbox.nodeName == "BODY") textbox.textContent = s
    else textbox.value = s
}

// loads the given *url* into the given *selectedBrowser*, and when it has loaded,
// it calls *thenDoThis*
function goToUrl(selectedBrowser, url, thenDoThis, inNewWindow) {
	//inNewWindow can be null, "inNewTab", or "inNewWindow"
	switch (inNewWindow) {
		case "inNewWindow":
			selectedBrowser.contentWindow.open(url)
			break;
		case "inNewTab":
			var chromeDocument = selectedBrowser.ownerDocument
			var tabBrowser = chromeDocument.getElementById("content")
			var newTab = tabBrowser.addTab(url)
			tabBrowser.selectedTab = newTab
			break;
		default:
			//debug("goToUrl is loading " + url)
			selectedBrowser.loadURI(url)
			break;
	}
    betterThenDoThis(getWindowRoot(selectedBrowser.ownerDocument.defaultView), thenDoThis)
}

function openNewTab(window, thenDoThis) {
	var tabBrowser = getMainTabbrowser(window)
	var newTab = tabBrowser.addTab("about:blank")
	tabBrowser.selectedTab = newTab
    betterThenDoThis(getWindowRoot(window), thenDoThis)
}

function closeTab(window, tab, thenDoThis) {
	var tabBrowser = getMainTabbrowser(window)
	tabBrowser.removeTab(tab)
    betterThenDoThis(getWindowRoot(window), thenDoThis)
}

function selectTab(window, tab, thenDoThis) {
	var tabBrowser = getMainTabbrowser(window)
	tabBrowser.selectedTab = tab
	betterThenDoThis(getWindowRoot(window), thenDoThis)
}

// Returns the (index)th tab, where 0 is the first tab.
function getTab(window, index) {
	return getMainTabbrowser(window).tabContainer.childNodes[index];	
}

// End execution functions
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// Functions for generating recorded slop

// findUniqueDescriptor
/*
This function is called by:
	completeCommandData in recorder, to break any ties in the target description about to be recorded, or currently being interpreted.
	listCommands in slop-interpreter -- with null matchingTargets.   It is trying to match the slop to an element on the page and there has been a high-score tie, so it looks to see if a unique descriptor has been included to break the tie.
NOTE that FORMERLY, this function was also called from makeThisTheRunLine after a recorded command was parsed. Since this routine was called by completeCommandData to create the recorded command, calling it again for all of the matches will surely find the correct one.

Algorithm: exclude the longest common path from the root, since it is identical for 2 targets, 
and so it can't be used to distinguish them.
Work your way up the remainder of the path, starting at the leaf, to find an ancestor with distinguishing visible text.
That is, try to find visible text that labels an ancestor node, or possibly a suitable sibling of the ancestor.  
It is possible that a different matchingTarget -- not on the longest common path, -- will also match this so-called "unique descriptor".  I'll wait for that to happen before dealing with it. 
For instance, suppose the MLS page had a duplicate table on the left half of the page for Rental instead of Purchase. I would use "zip code" to distinguish the Purchase Continue buttons, but there would be a matching zip code Rental Continue button.  A label at the top of the two branches (eg "Rental" and "Purchase") would be ideal. Ultimately, it may be better to find a unique descriptor by comparing target to each of the matchingTargets.(AC)  
In the first two examples I looked at, there are long common paths from the leaves. 
Heuristic for table elements: for a node like tr[3], look at tr[3] for differentiating text. Then at tr[2] (and possibly tr[4]?) since they are adjacent.  To determine adjacency, skip over table siblings that are spacers. Then look at tr[1] since it is the first element of the table, and may well label the row. 
*/
// these matchingTargets all generate the same label and type.
//Find a descriptor that distinguishes the target from the rest of the matchingTargets
//This code can be simplified by turning the XPath into an array of segments(AC)
function findUniqueDescriptor(target, matchingTargets) {
	// TL: [#89083] Unique descriptors are not interpreted, 1/9/08
	// The interpreter cannot interpret non-ordinal unique descriptors at
	// the moment, so we will temporarily switch to using only ordinal
	// descriptors here.  Re-enable the code below once the interpreter can
	// parse non-ordinal unique descriptors.
	for (i = 0; i<matchingTargets.length; i++) {
		if (matchingTargets[i] == target) return (getOrdinal(i+1))
	}
	return;

//1. Find longestCommonPath
	var i
	var maxLabelLength = 50 // make sure this is the same length used in slopInterpreter's listCommands
	var targetXPath = getXPath(target)
	var matchingTargetXPath = ""
	var commonPath = ""
	var longestCommonPath = ""
	var longestCommonMatchingTarget = ""	//the matchingTarget that has the longest XPath in common with target
	var longestCommonMatchingTargetXPath = "" // the complete XPath for the longestCommonMatchingTarget
	var segmentPattern = /(.*?)\//g  //non-greedily find each segment between slashes
	var segmentPatternCopy = /(.*?)\//g  
	var lastIndex = 0
	var targetSegment, matchingTargetSegment
	for (i = 0; i<matchingTargets.length; i++) {
		matchingTargetXPath = getXPath(matchingTargets[i])
		if (matchingTargetXPath == targetXPath) {continue}// one of them is the target: don't compare to self
		// find longestCommonPath
		// walk down targetXPath and matchingTargetXPath until they no longer match
		segmentPatternCopy.lastIndex = segmentPattern.lastIndex = (lastIndex = 0)
		while ( (targetSegment = segmentPattern.exec(targetXPath)) &&
					(matchingTargetSegment = segmentPatternCopy.exec(matchingTargetXPath)) &&
					(targetSegment[1] == matchingTargetSegment[1] )
				  ) {
			lastIndex = segmentPattern.lastIndex
		}
		commonPath = targetXPath.slice(0, lastIndex-1)
		if (commonPath.length > longestCommonPath.length){
			longestCommonPath = commonPath
			longestCommonMatchingTarget = matchingTargets[i]
			longestCommonMatchingTargetXPath = matchingTargetXPath  
		}
	}
	
	//simplify the name of the longestCommonMatchingTarget
	// **So, matchingTarget is the other object on the page that is most likely to be mistaken for the target, 
	//since it has the same label and type, and it appears in the same section of the page
	var matchingTarget = longestCommonMatchingTarget
	matchingTargetXPath = longestCommonMatchingTargetXPath

/*
	//2. Start at the leaf and work up, looking for visible text in an ancestor of the target that distinguishes it 
	//from the corresponding ancestor of the matchingTarget. 
	//Stop looking once the ancestors are not of the same type.
	// I may want to keep track of distinguishing alt's (and id's?) along the way, in case no visible text is found.
	
	// Example where targetXPath and matchingTargetXPath differ:
	// "Admin" link on IIOSB Bug page.
	// targetXPath = 				"/html[1]/body[1]/div[5]/  div[2]  /p[1]/strong[1]/		a[6]"
	// matchingTargetXPath = 	"/html[1]/body[1]/div[5]/  div[1]  /div[1]/ul[1]/li[2]/	a[1]"
	//In this case, distinguish them by ordinals

Example (from Amazon.com homepage search textboxes at top and bottom of page) where target and matchingTarget have quite different XPaths:
	
targetXPath: 
"/HTML[1]/BODY[1]/
TABLE[2]/TBODY[1]/TR[1]/TD[1]/
TABLE[2]/TBODY[1]/TR[1]/TD[2]/
FORM[1]/
-
TABLE[1]/TBODY[1]/TR[1]/TD[4]/INPUT[1]"

matchingTargetXPath: 
"/HTML[1]/BODY[1]/
-
-
FORM[1]/
TABLE[1]/TBODY[1]/TR[2]/TD[1]/
TABLE[1]/TBODY[1]/TR[1]/TD[1]/INPUT[1]"
*/

	// Get the index for each path segment in targetXPath and in matchingTargetXPath, 
	//working from the leaf to 'the first segment where target and matchingTarget have different types.'
	segmentPattern.lastIndex = longestCommonPath.length
	var targetSegmentIndices = []
	while (targetSegment = segmentPattern.exec(targetXPath)) {
		targetSegmentIndices.push(segmentPattern.lastIndex-1)
	}
	targetSegmentIndices.reverse()
	
	segmentPatternCopy.lastIndex = longestCommonPath.length
	var matchingTargetSegmentIndices = []
	while (matchingTargetSegment = segmentPatternCopy.exec(matchingTargetXPath)) {
		matchingTargetSegmentIndices.push(segmentPatternCopy.lastIndex-1)
	}
	matchingTargetSegmentIndices.reverse()
	
	//Example: Ancestors of the 'Search for' textbox on the Bond home page:
	//'Search for' (which is not distinguishing); 
	//then a tr[3] element with 
	//		adjacent tr[2] labelled "Search on commodity code or name. You may also choose to browse commodities by clicking the "View commodities" link." 
	//		and tr[1] labelled "Shop by commodity"
	// A smarter thing to do would be to look for spacer columns in a table, to indicate that an adjacent column may be a label
	var uniqueLabels = []
	var targetIndex
	var matchingTargetIndex
	var targetAncestorXPath
	var matchingTargetAncestorXPath
	var segmentNamePattern = /(.*?)\[/g
	var segmentNamePatternCopy = /(.*?)\[/g
	var targetSegmentName
	var matchingTargetSegmentName 
	var targetAncestorLabel
	var matchingTargetAncestorLabel
	var targetSegmentType
	var matchingTargetSegmentType
	//var retry
	for (i = 0;  i<Math.min(targetSegmentIndices.length, matchingTargetSegmentIndices.length); i++) {
		segmentNamePattern.lastIndex = targetSegmentIndices[i]+1
		segmentNamePatternCopy.lastIndex = matchingTargetSegmentIndices[i]+1
		targetIndex = targetSegmentIndices[i]
		matchingTargetIndex = matchingTargetSegmentIndices[i]
		targetAncestorXPath = targetXPath.slice(0, targetIndex)
		matchingTargetAncestorXPath = matchingTargetXPath.slice(0, matchingTargetIndex)
		if (!targetAncestorXPath) return uniqueLabels  // called from listCommands. we're now at the root
		
		//don't look for labels past the point where target and matchingTarget have different types
		targetSegmentName = segmentNamePattern.exec(targetXPath)[1]
		matchingTargetSegmentName = segmentNamePatternCopy.exec(matchingTargetXPath)[1]
		if(targetSegmentName != matchingTargetSegmentName) break;
		
		// Find the label for the ancestor, 
		//and make sure it differs from the text for the matchingAncestor
		targetAncestorLabel = getLabel(getNode(targetAncestorXPath, target.ownerDocument))
		matchingTargetAncestorLabel = getLabel(getNode(matchingTargetAncestorXPath, matchingTarget.ownerDocument))
		if (targetAncestorLabel != matchingTargetAncestorLabel) {
			if (targetAncestorLabel.length > maxLabelLength) targetAncestorLabel = targetAncestorLabel.substring(0, maxLabelLength) + "..."
			uniqueLabels.push(targetAncestorLabel)
		}

		// Also consider the first label in a table row.
		//if this is given precedence over an adjacent label, we could get rid of the kludgey wordCount(uniqueLabels[i])  < 5 below
		if (targetAncestorXPath.search(/\/TR\[\d*\]$/)+1) {
			targetAncestorXPath.replace(/\/TR\[\d*\]$/, "/tr[1]")
			targetAncestorLabel = getLabel(getNode(targetAncestorXPath, target.ownerDocument))
			matchingTargetAncestorXPath.replace(/\/TR\[\d*\]$/, "/tr[1]")
			matchingTargetAncestorLabel = getLabel(getNode(matchingTargetAncestorXPath, target.ownerDocument))
			if (targetAncestorLabel != matchingTargetAncestorLabel) {
				if (targetAncestorLabel.length > maxLabelLength) targetAncestorLabel = targetAncestorLabel.substring(0, maxLabelLength) + "..."
				uniqueLabels.push(targetAncestorLabel)
			}
		} // end of first label in a table row
	} // end of walking up ancestors
	
	//choose the best label.
	// For now, pick the first short one
	// BUT, if matchingTargets is null, findUniqueDescriptor was called by listCommands to see if any of its 
	//interpretations match the ancestor descriptor of the command it is interpreting, 
	// SO, return all ancestors
	//It could call findUniqueDescriptor on each top-scoring command, but that is n^2 work.
	//Or we could create a full ancestor path for each top-scoring target, and then intersect them 
	//to find the common path, but that would mean re-writing this routine. (AC)
	if (!matchingTargets) return uniqueLabels
	for (var i=0; i<uniqueLabels.length; i++) {
		if (wordCount(uniqueLabels[i])  < 5) return uniqueLabels[i]
	}
	if (uniqueLabels[0]) {return uniqueLabels[0]}
	else {
		// return an ordinal -- the position of target in matchingTargets
		for (i = 0; i<matchingTargets.length; i++) {
			if (matchingTargets[i] == target) return (getOrdinal(i+1))
		}
	}
}	// end of findUniqueDescriptor

function countSameTypePriorSiblings(node) {
   //returns the appropriate xPath string
    var originalNodeName = node.nodeName
    var count = 1
    while (node.previousSibling) {
		node = node.previousSibling
		if (node.nodeName == originalNodeName) count++
    }
	// kludge for http://pokl22wam.pok.ibm.com/wac/Controller?action=root
	//where HTML's previous sibling has name HTML instead of html
	//because source starts with <!DOCTYPE HTML ...  instead of <!DOCTYPE html ...
	if (originalNodeName == "HTML") count=1  
    return "/" + originalNodeName + "[" + count + "]"
}

function tabCount(targetElement) {
	if (!targetElement || !("ownerDocument" in targetElement)) return 0
	var targetWindow = targetElement.ownerDocument.defaultView
	var mainChromeWindow = getMainChromeWindow(targetWindow)
	var tabBrowser = mainChromeWindow.document.getElementById("content")
	if (tabBrowser) return tabBrowser.browsers.length
	return 0
}

function windowCount() {
	var windowMediator = CC["@mozilla.org/appshell/window-mediator;1"].getService(CI.nsIWindowMediator)
	var windowEnumerator = windowMediator.getEnumerator(null)
	for(var count=0; windowEnumerator.getNext(); count++){}
	return count
}

// End slop recording functions
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// SSL Cert Exception handling functions

function addSSLCertException(location, gBrowser, onExceptionAdded) {
    checkCert(location, addExceptionAndReload);

    function addExceptionAndReload(uri, sslStatus, cert) {
        if (addException(uri, sslStatus, cert)) {
            location.reload(true);
            onExceptionAdded();
        }
    }

    // code until the end of the SSL Cert functions is adapted from
    // /mozilla-central/security/manager/pki/resources/content/exceptionDialog.js
    // license MPL

    /**
     * Attempt to download the certificate for the location specified,
     * call callback passing uri, sslStatus and cert as parameters
     */
    function checkCert(location, callback) {
      var cert = null, sslStatus = null;

      var uri = getURI(location);

      var req = Components.classes["@mozilla.org/xmlextras/xmlhttprequest;1"].createInstance(Components.interfaces.nsIXMLHttpRequest);

      try {
        if(uri) {
          req.mozBackgroundRequest = true;
          req.open('GET', uri.prePath, true);
          req.onreadystatechange = function (aEvt) {
            if (req.readyState == 4) {
              if(req.channel && req.channel.securityInfo) {
                const Ci = Components.interfaces;
                sslStatus = req.channel.securityInfo
                                .QueryInterface(Ci.nsISSLStatusProvider).SSLStatus;
                cert = sslStatus.QueryInterface(Ci.nsISSLStatus).serverCert;

                callback(uri, sslStatus, cert);
              }
            }
          };

          req.send(null);

        }
      }
      catch (e) {
        // We *expect* exceptions if there are problems with the certificate
        // presented by the site.  Log it, just in case, but we can proceed here,
        // with appropriate sanity checks
        Components.utils.reportError("Attempted to connect to a site with a bad certificate in the add exception dialog. " +
                                     "This results in a (mostly harmless) exception being thrown. " +
                                     "Logged for information purposes only: " + e);
      }
    }

    /**
     * Build and return a URI, based on the information supplied in the
     * Certificate Location fields
     */
    function getURI(location) {
      // Use fixup service instead of just ioservice's newURI since it's quite likely
      // that the host will be supplied without a protocol prefix, resulting in malformed
      // uri exceptions being thrown.
      var fus = Components.classes["@mozilla.org/docshell/urifixup;1"]
                          .getService(Components.interfaces.nsIURIFixup);
      var uri = fus.createFixupURI(location.href, 0);

      if(!uri)
        return null;

      if(uri.scheme == "http")
        uri.scheme = "https";

      if (uri.port == -1)
        uri.port = 443;

      return uri;
    }

    /**
     * Handle user request to add an exception for the specified cert
     */
    function addException(uri, sslStatus, cert) {
      if(!cert || !sslStatus)
        return false;

      var overrideService = Components.classes["@mozilla.org/security/certoverride;1"]
                                      .getService(Components.interfaces.nsICertOverrideService);
      var flags = 0;
      if(sslStatus.isUntrusted)
        flags |= overrideService.ERROR_UNTRUSTED;
      if(sslStatus.isDomainMismatch)
        flags |= overrideService.ERROR_MISMATCH;
      if(sslStatus.isNotValidAtThisTime)
        flags |= overrideService.ERROR_TIME;

      // TODO: this could be in preferences
      var shouldStorePermanently = true;

      overrideService.rememberValidityOverride(
        uri.asciiHost, uri.port,
        cert,
        flags,
        !shouldStorePermanently);

      return true;
    }

    // end SSL Cert Exception handling functions
    //----------------------------------------------------------------------
}

// ----------------------------------------------------------------------
// Preferences utility functions
/*****************************************
 *  Stuff dealing with preferences
 *  FYI, default preferences go into xpi/defaults/preferences/coscripter.js
 *****************************************/
 
/* ----------------------------------------------------------------------
 * Get the Mozilla preferences branch belonging to CoScripter
 */
function getCoScripterPrefs(){
    return Components.classes["@mozilla.org/preferences-service;1"].getService(Components.interfaces.nsIPrefService).getBranch("coscripter.");
}

/*****************************************
 *  End Stuff dealing with preferences
 *****************************************/
// End preferences functions
// ----------------------------------------------------------------------


// ----------------------------------------------------------------------
// Koalescence API functions and CoScripter version

function getKoalescenceURL() {
	var prefs = getCoScripterPrefs();
	var defaultServer = prefs.getIntPref("defaultServer");
	var serverList = JSON.parse(prefs.getCharPref("serverList"));

	return serverList[defaultServer]["url"];
}

function getKoalescenceAPIFunction(method, query) {
    try {

		var prefs = getCoScripterPrefs();
		var defaultServer = prefs.getIntPref("defaultServer");
		var serverList = JSON.parse(prefs.getCharPref("serverList"));

		var apiURL = serverList[defaultServer]["url"];
		if (apiURL[apiURL.length - 1] != '/') apiURL += '/';
		apiURL = apiURL + 'api/' + method;
		if (query) apiURL = apiURL + '?' + query;
		return apiURL;
    } catch (e) {
		d('error getting koalescence url: ' + e + '\n')
    }
}
 
function coscripterVersion(){
	try{
		Components.utils.import("resource://gre/modules/AddonManager.jsm");
//		var myID = '{353396a4-6910-4b95-9ec8-37978867618b}'
//		var em = Components.classes["@mozilla.org/extensions/manager;1"].getService(Components.interfaces.nsIExtensionManager);
//		var item = em.getItemForID(myID)
//		var v = item.version;
		return '1.10.0';
	}catch(e){
		return 'unknown'
	}
}

// End Koalescence API and version functions
// ----------------------------------------------------------------------

function getLabeler(){
	return registry.labeler();
}

function getCommands(){
	return registry.commands()
} 	
	

